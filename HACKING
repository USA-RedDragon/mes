-*-mode:org-*-

* Fully source-based bootstrapping

** R6RS-like scheme interpreter
This first part is prototyped in C by the mes.c core and Scheme
bootstrap code in module/.  Of course, while mes.c is pretty small it
cannot serve as a fully source-based solution.

The initial idea was to have the minimal core support LISP-1.5 (or
something very close to that as a tribute to John McCarthy) and extend
eval/apply from LISP-1.5 source with define, define-macro etc. and
metamorphose into R6RS.  It seemed to work but performance of the
LISP-intepreted RRS was so bad (~1000x slower than initial LISP-1.5)
that this track was abandoned after the initial ANNOUNCE.

The route changed, trying to strike a balance between core size and
performance: still writing as much as possible in Scheme but having a
mescc compiler that takes not more than some seconds to run.

Now that we have [[https://github.com/schemeway/lalr-scm][Dominique Boucher's LALR]], a [[https://www.cs.indiana.edu/chezscheme/syntax-case/old-psyntax.html][Pre-R6RS portable
syntax-case]] with R7RS ellipsis, [[http://www.nongnu.org/nyacc/][Nyacc]] and [[https://www.gnu.org/software/guile/docs/master/guile.html/PEG-Parsing.html][Guile's PEG]] parsers, it's
time to start doing something useful.

* Bugs
** The Scheme reader is very slow.
** Catch/throw are a syntax only hack for Nyacc.
** Fluids are a hack for Nyacc.
** Prototype mes.c depends on a C compiler.
*** Translate C-prototype mes.c into annotated hex?
One idea is to use OriansJ's amazing self-hosting [[https://github.com/oriansj/stage0][stage0]] hex assembler
and minimal bootstrap binaries and rewrite the mes.c core to directly
bootstrap into Scheme.

*** Rewrite mes.c in Schemy/Sexp-C and generate annotated hex?
Another idea (thanks Rutger!) is to rewrite the mes.c core in a s-exp
C/Assembly variant and thave mescc produce the simple, annotated
bootstrap binary.

** Actually do something useful
*** Rewrite the mescc compiler to work on the Nyacc AST.
The proof-of-concept mescc compiler uses a simple, whoefully
incomplete AST produced by a simplistic LALR-based C-parser.
*** Implement more bits of the compiler.
As Mes now runs Nyacc, and Guile runs the mescc compiler, this
compiler can be developed using Guile.
*** Compile mes.c using mescc.
A first milestone, next up is...
*** Compile the [[https://en.wikipedia.org/wiki/Tiny_C_Compiler][Tiny C Compiler]]

* OLD: Booting from LISP-1.5 into Mes

Mes started out experimenting with booting from a hex-coded minimal
LISP-1.5 (prototype in mes.c), into an almost-RRS Scheme.

When EOF is read, the LISP-1.5 machine calls loop2 from loop2.mes,
which reads the rest of stdin and takes over control.  The functions
readenv, eval and apply-env in mes.mes introduced define, define-macro
quasiquote and macro expansion.

While this works, it's amazingly slow.  We implemented a full reader
in mes.c, which makes running mes:apply-env mes:eval somewhat
bearable, still over 1000x slower than running mes.c.

Bootstrapping has been removed and mes.c implements enough of RRS to
run a macro-based define-syntax and syntax-rules.

loop.mes and mes.mes are unused and lagging behind.  Probably it's not
worth considering this route without a VM.  GNU Epsilon is taking the
more usual VM-route to provide multiple personas.  While that sounds
neat, Lisp/Scheme, bootstrapping and trusted binaries are probably not
in scope as there is no mention of such things; only ML is mentioned
while Guile is used for bootstrapping.

* Assorted ideas and info 
** Using GDB on assembly/a.out
info registers
p/x $eax
p/x $edx
set disassemble-next-line
gdb-display-disassembly-buffer
b *0x804a79d
** Create memory dump with 32 bit Gcc compiled Mes
guix environment --ad-hoc --system=i686-linux gcc-toolchain -- bash -c 'make mes CC=i686-unknown-linux-gnu-gcc LIBRARY_PATH=${PATH%%/bin:*}/lib'
MES_HACK=1 ./mes-32 --dump < module/mes/read-0.mes > module/mes/read-0-32.mo
** C parser/compiler
*** [[https://savannah.gnu.org/projects/nyacc][nyacc]]
*** PEG: [[http://piumarta.com/software/peg/][parse C using PEG]]
*** [[https://en.wikipedia.org/wiki/Tiny_C_Compiler][Tiny C Compiler]]
*** [[http://www.t3x.org/subc/index.html][Sub C]]
*** [[https://groups.google.com/forum/#!topic/comp.lang.lisp/VPuX0VsjTTE][C intepreter in LISP/Scheme/Python]]

** C assembler/linker
*** [[http://www.tldp.org/HOWTO/Assembly-HOWTO/linux.html][Assembly HOWTO]]
*** System call clue bat
Basically, you issue an int 0x80, with the __NR_syscallname number
(from asm/unistd.h) in eax, and parameters (up to six) in ebx, ecx,
edx, esi, edi, ebp respectively.
*** ELF
7f 45 4c 46
*** [[http://www.muppetlabs.com/~breadbox/software/tiny/][Small ELF programs]]
*** [[http://www.cirosantilli.com/elf-hello-world/][Elf hello world]]

** SC - c as s-expressions
sc: http://sph.mn/content/3d3
** RNRS
*** [[http://www.scheme-reports.org/][Scheme Reports]] 
*** [[ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-349.pdf][Scheme - Report on Scheme]]
*** [[ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-452.pdf][RRS - Revised Report on Scheme]]

** tiny schemes
http://forum.osdev.org/viewtopic.php?f=15&t=19937

http://www.stripedgazelle.org/joey/dreamos.html
http://armpit.sourceforge.net/
http://common-lisp.net/project/movitz/movitz.html

<civodul> janneke: https://github.com/namin/inc looks interesting  [15:18]
