;;; -*-scheme-*-

;;; Mes --- Maxwell Equations of Software
;;; Copyright Â© 2016 Jan Nieuwenhuizen <janneke@gnu.org>
;;;
;;; base-0.mes: This file is part of Mes.
;;;
;;; Mes is free software; you can redistribute it and/or modify it
;;; under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 3 of the License, or (at
;;; your option) any later version.
;;;
;;; Mes is distributed in the hope that it will be useful, but
;;; WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with Mes.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;;; base-0.mes is the first file being loaded from the Mes core.  It
;;; provides primitives that use Mes internals to create the illusion
;;; of compatibility with Guile.  It is not safe to be run by Guile.

;;; Code:

(define (primitive-eval e) (eval-env e (current-module)))
(define eval eval-env)
(define (expand-macro e) (expand-macro-env e (current-module)))

(define quotient /)

(define-macro (defined? x)
  (list 'assq x '(cddr (current-module))))

(if (defined? 'current-input-port) #t
    (define (current-input-port) 0))

(define (current-output-port) 1)
(define (current-error-port) 2)
(define (port-filename port) "<stdin>")
(define (port-line port) 0)
(define (port-column port) 0)
(define (ftell port) 0)
(define (false-if-exception x) x)

(define (cons* x . rest)
  (define (loop rest)
    (if (null? (cdr rest)) (car rest)
        (cons (car rest) (loop (cdr rest)))))
  (loop (cons x rest)))

(define (apply f h . t) (apply-env f (cons h t) (current-module)))
(define (apply f h . t)
  (if (null? t) (apply-env f h (current-module))
      (apply f (apply cons* (cons h t)))))

(define-macro (cond . clauses)
  (list 'if (null? clauses) *unspecified*
        (if (null? (cdr clauses))
           (list 'if (car (car clauses))
                 (list (cons 'lambda (cons '() (cons (car (car clauses)) (cdr (car clauses))))))
                 *unspecified*)
           (if (eq? (car (cadr clauses)) 'else)
               (list 'if (car (car clauses))
                   (list (cons 'lambda (cons '() (car clauses))))
                   (list (cons 'lambda (cons '() (cons *unspecified* (cdr (cadr clauses)))))))
               (list 'if (car (car clauses))
                   (list (cons 'lambda (cons '() (car clauses))))
                   (cons 'cond (cdr clauses)))))))

(define else #t)

(define (map f l . r)
  (if (null? l) '()
      (if (null? r) (cons (f (car l)) (map f (cdr l)))
          (if (null? (cdr r))
              (cons (f (car l) (caar r)) (map f (cdr l) (cdar r)))))))

(define-macro (simple-let bindings . rest)
  (cons (cons 'lambda (cons (map car bindings) rest))
        (map cadr bindings)))

(define-macro (let bindings . rest)
  (cons 'simple-let (cons bindings rest)))

(define *input-ports* '())
(define-macro (push! stack o)
  `(begin
     (set! ,stack (cons ,o ,stack))
     ,stack))
(define-macro (pop! stack)
  `(let ((o (car ,stack)))
     (set! ,stack (cdr ,stack))
     o))
(define-macro (load file)
  `(primitive-eval
    (begin
      (push! *input-ports* (current-input-port))
      (set-current-input-port (open-input-file ,file))
      (primitive-load)
      (set-current-input-port (pop! *input-ports*)))))
