-*-mode:org-*-

* SETUP
    guix environment -l guix.scm     #64 bit + 32bit
    guix environment --system=i686-linux -l guix.scm #32 bit only
* BUILD
There are two major modes to build Mes: true bootstrap and
development.

** DEVELOPMENT BUILD
To help development we assume ./configure sets these variables for make

   CC     -- gcc
   CC32   -- i686-unknown-linux-gnu-gcc (or on x86, also gcc)
   GUILE  -- guile
   HEX2   -- hex2
   MES    -- unset
   M1     -- M1
   PREFIX -- ""

Mes is supposed to serve as a full equivalent for Guile, however mes is much, much
slower than guile.  That's why we usually don't use mes during development.

gcc is used to verify the sanity of our C sources.

i686-unknown-linux-gnu-gcc is used to compare hex/assembly, to test
the gcc variant of mes libc: lib/libc-gcc.c and steal ideas.

Guile is used to develop mescc, the C compiler in Scheme that during
bootstrapping will be executed by mes.

** BOOTSTRAP BUILD
In bootstrap mode, we don't have gcc (CC), we don't have pa 32 bit gcc
(CC32), we have no guile (GUILE)...but we should have hex2, M1, and
FIXME: mes.M1.

mes is built from src/*.c and some out/src/*.h files that are snarfed from
src/*.c by build-aux/mes-snarf.scm.

Running ./make.scm produces a `script' file.

* ROADMAP
** TODO 
*** release 0.12
  - mescc: compile a mes-tcc that can compile gcc-4.7.
*** release 0.x, unsorted
  - mescc: refactor type(/ptr?) system; expr->type and ast-type->type.
  - mescc: refactor initializers.
  - mescc: record and support function types, and thus foo ()->bar.
  - mescc: refactor switch statement to support unpatched tinycc.
  - mes/mescc: bootstrap a minimal-Guile (libguile/eval.c,ice-9/eval.scm).
  - mescc: have mes-tcc pass all scaffold/tests, scaffold/tinycc tests.
  - mescc: compile a mes-tcc that can compile gcc-4.7.
  - mescc: refactor switch; support heterogeneous switch case.
  - mescc: support sizeof any expr.
  - mescc: support function-static.
  - mescc: support/grok global static.
  - mescc: support unsigned comparison, arithmetic.
  - mescc: support long long.
  - mescc: support bitfields.
  - mescc: support floats.
  - mescc: some success with 8cc,pcc,guile/libguile/eval.c.
  - build: guile/guix/make.scm: add file-types, intermediate, hash all dependencies
  - build: make.scm: imperative->declaritive
  - hex2: produce ELF_sym and ELF_str tables from hex2; nicer for objdump -d, gdb (in mescc-tools?)
  - compile src/mes.c with M2-Planet.
  - rewrite src/mes.c in stage0's stage2 LISP.
  - and/or: rewrite src/mes.c M1
  - and/or: connect to GNU Epsilon's VM
  - and/or: compile Scheme to C, rewrite Mes.c into Mes.scm.
  - real module support, bonus for supporting Guile's define-module/define-public syntax.
  - get full source syntax-case up (Andre van Tonder?) OR drop it.
    psyntax/syntax-case and rewrite Nyacc without syntax-case+R7RS Ellipsis.
  - support regexp OR rewrite Nyacc without regexps.
  - split-off MesCC as as standalone Guile C compiler project.
*** release 1.0
  - replace GuixSD's bootstrap binaries for x86.
  - add x86_64, replace GuixSD's bootstrap binaries for x86_64.
  - more architectures?
** DONE
*** 0.11: MesCC now compiles a mes-tcc that passes 41/69 of mescc's C tests.
*** 0.10: Mescc now compiles a mes-tcc that compiles a trivial C to a running a.out.
*** 0.9: Mescc now writes M1 macro assembly files and compiles tcc.
*** 0.8: Mescc now writes object files in stage0's labeled hex2 format.
*** 0.7: Mescc supports -E, -c, -o options, include more complete set of header files,
eenough to work on compiling tinycc's tcc.c albeit a somewhat modified version.
*** 0.6: Work with unmodified, unbundled Nyacc; compile 33/55 tinycc's tests/test2 suite.
*** 0.5: Mutual self-hosting Scheme interpreter and C compiler: mes.c and mescc,
         Support call-with-current-continuation, refactor catch/throw
*** 0.4: Support Nyacc, Gcc-compiled Mes compiles minimal main.c using nyacc
*** 0.3: Garbage collector
*** 0.2: Support psyntax
*** 0.1: Mes eval/apply feature complete; support syntax-rules, compile main.c using LALR, dump ELF

* Bugs
** eval_apply/gc + Nyacc bug
scripts/messc.mes intermittently exposes a bug in eval_apply/gc when
Nyacc parses mes.c-sized source.  Running 

    MES_MAX_ARENA=<another-size> scripts/mescc.mes

may [un]cover the bug.  So there is probably some eval_apply-construct
that Nyacc uses, possiblby indirectly via with-fluid, like (call/cc,
call-with-current-continuation), that breaks when GC triggers at the
wrong time.
** mescc can only compile itself, it cannot full-functionally compile tcc, gcc or guile
** mescc: 7n-struct-struct-array.c:  struct file f = {"first.h"};
** mes.mes cannot read sexps, only --dump's, mes.mes cannot --dump
** Bootstrap binary mes is too big and opaque to be considered source
68kB ELF binary which can be disassembled (objdump -d mes.mes).
** Psyntax is too big and opaque to be considered source
And needs a patched Guile-1.8 to [re]generate.
** test/match.test ("nyacc-simple"): hygiene problem in match
** Performance
*** mes is slow
*** The Scheme reader is very slow.
*** mescc is slow
**** compiling mes.c takes mescc.mes 2h30'
mescc.scm which runs on Guile takes 30"
** Fluids are a hack for Nyacc.
*** Translate C-prototype mes.c into annotated hex?
One idea is to use OriansJ's amazing self-hosting [[https://github.com/oriansj/stage0][stage0]] hex assembler
and minimal bootstrap binaries and rewrite the mes.c core to directly
bootstrap into Scheme.

*** Rewrite mes.c in Schemy/Sexp-C and generate annotated hex?
Another idea (thanks Rutger!) is to rewrite the mes.c core in a s-exp
C/Assembly variant and thave mescc produce the simple, annotated
bootstrap binary.

*** Compile the [[https://en.wikipedia.org/wiki/Tiny_C_Compiler][Tiny C Compiler]]

** Build tools do not run on mes
*** configure needs Bash, Guile
*** GNUmakefile needs Bash, Guile
*** build-aux/mes-snarf.scm needs Guile
*** build-aux/git-changelog needs Perl
* OLD: Booting from LISP-1.5 into Mes

Mes started out experimenting with booting from a hex-coded minimal
LISP-1.5 (prototype in mes.c), into an almost-RRS Scheme.

When EOF is read, the LISP-1.5 machine calls loop2 from loop2.mes,
which reads the rest of stdin and takes over control.  The functions
readenv, eval and apply-env in mes.mes introduced define, define-macro
quasiquote and macro expansion.

While this works, it's amazingly slow.  We implemented a full reader
in mes.c, which makes running mes:apply-env mes:eval somewhat
bearable, still over 1000x slower than running mes.c.

Bootstrapping has been removed and mes.c implements enough of RRS to
run a macro-based define-syntax and syntax-rules.

loop.mes and mes.mes are unused and lagging behind.  Probably it's not
worth considering this route without a VM.  GNU Epsilon is taking the
more usual VM-route to provide multiple personas.  While that sounds
neat, Lisp/Scheme, bootstrapping and trusted binaries are probably not
in scope as there is no mention of such things; only ML is mentioned
while Guile is used for bootstrapping.

* Assorted ideas and info 
** Using GDB on assembly/a.out
info registers
p/x $eax
p/x $edx
set disassemble-next-line
gdb-display-disassembly-buffer
b *0x804a79d
** Create memory dump with 32 bit Gcc compiled Mes
make out/i686-unknown-linux-gnu-mes
out/i686-unknown-linux-gnu-mes --dump < module/mes/read-0.mes > module/mes/read-0-32.mo
** C parser/compiler
*** [[https://savannah.gnu.org/projects/nyacc][nyacc]]
*** PEG: [[http://piumarta.com/software/peg/][parse C using PEG]]
*** [[https://en.wikipedia.org/wiki/Tiny_C_Compiler][Tiny C Compiler]]
*** [[http://www.t3x.org/subc/index.html][Sub C]]
*** [[https://groups.google.com/forum/#!topic/comp.lang.lisp/VPuX0VsjTTE][C intepreter in LISP/Scheme/Python]]

** C assembler/linker
*** [[http://www.tldp.org/HOWTO/Assembly-HOWTO/linux.html][Assembly HOWTO]]
*** ELF
7f 45 4c 46
*** [[http://www.muppetlabs.com/~breadbox/software/tiny/][Small ELF programs]]
*** [[http://www.cirosantilli.com/elf-hello-world/][Elf hello world]]
** SC - c as s-expressions
sc: http://sph.mn/content/3d3
** RNRS
*** [[http://www.scheme-reports.org/][Scheme Reports]] 
*** [[ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-349.pdf][Scheme - Report on Scheme]]
*** [[ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-452.pdf][RRS - Revised Report on Scheme]]

** tiny schemes
http://forum.osdev.org/viewtopic.php?f=15&t=19937

http://www.stripedgazelle.org/joey/dreamos.html
http://armpit.sourceforge.net/
http://common-lisp.net/project/movitz/movitz.html

<civodul> janneke: https://github.com/namin/inc looks interesting  [15:18]
** Orians Jeremiah
<OriansJ> janneke: also, if you look at
          https://github.com/oriansj/stage0/tree/master/stage2/High_level_prototypes
          [the garbage collected lisp I implemented], if there are any pieces
          I could add to finish off your mes lisp bootstrap just let me know
          because I would be more than happy to do that :D
<janneke> OriansJ: that's what I'm hoping for, that our efforts can be
          complementary and we can work together
*** lfam (~lfam@2601:47:4180:2ffb:7c05:17de:cf5f:23ef) has quit: Ping timeout:
    246 seconds  [00:22]
<janneke> exciting times!  [00:23]
<janneke> OriansJ: i looked a few times and saw 'LISP empty', so thanks for
          the pointer!  [00:24]
<civodul> OriansJ, janneke: from that page, there's also:
          https://web.archive.org/web/20160604035203fw_/http://homepage.ntlworld.com/edmund.grimley-evans/bcompiler.html

** C4/C500
https://web.archive.org/web/20160604041431/http://homepage.ntlworld.com/edmund.grimley-evans/cc500/cc500.c
https://github.com/rswier/c4/blob/master/c4.c
** Compilers for free
http://codon.com/compilers-for-free
** Small lisps
*** [[https://www.mirrorservice.org/sites/www.bitsavers.org/bits/TI/Explorer/zeta-c/][ZETA-C]]
** Small C compilers
*** tinycc
*** [[https://github.com/rui314/8cc][8cc]] -- a C11 compiler, but simple
8cc is a compiler for the C programming language. It's intended to
support all C11 language features while keeping the code as small and
simple as possible.
*** pcc
*** early GCC?
https://miyuki.github.io/2017/10/04/gcc-archaeology-1.html
*** [[http://tack.sourceforge.net/][ack]]
<rain1> it may be possible to compile like this:  mes |> ack |> pcc |> tcc |>
        gcc 4.7.4 |> gcc later version... up to modern
*** [[https://web.archive.org/web/20160402225843/http://homepage.ntlworld.com/edmund.grimley-evans/cc500/][cc500]]
** rain1's Bootstrapping Wiki: https://bootstrapping.miraheze.org/wiki/Main_Page
** rain1's hex86
https://notabug.org/rain1/hex86/src/master/tests/hex0b3.hex86

