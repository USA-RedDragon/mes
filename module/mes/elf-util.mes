;;; -*-scheme-*-

;;; Mes --- Maxwell Equations of Software
;;; Copyright Â© 2016,2017 Jan Nieuwenhuizen <janneke@gnu.org>
;;;
;;; This file is part of Mes.
;;;
;;; Mes is free software; you can redistribute it and/or modify it
;;; under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 3 of the License, or (at
;;; your option) any later version.
;;;
;;; Mes is distributed in the hope that it will be useful, but
;;; WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with Mes.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;;; compiler.mes produces an i386 binary from the C produced by
;;; Nyacc c99.

;;; Code:

(cond-expand
 (guile)
 (guile-2)
 (mes
  (mes-use-module (srfi srfi-1))))

(define (make-global name type pointer value)
  (cons name (list type pointer value)))

(define global:type car)
(define global:pointer cadr)
(define global:value caddr)

(define (dec->hex o)
  (cond ((number? o) (number->string o 16))
        ((char? o) (number->string (char->integer o) 16))))

(define (functions->lambdas functions)
  (append-map cdr functions))

(define (lambda/label->list f g ta t d)
  (lambda (l/l)
    (if (not (procedure? l/l)) '() (l/l f g ta t d))))

(define (text->list o)
  (append-map (lambda/label->list '() '() 0 0 0) o))

(define (functions->text functions globals ta t d)
  (let loop ((lambdas/labels (functions->lambdas functions)) (text '()))
    (if (null? lambdas/labels) text
        (loop (cdr lambdas/labels)
              (append text ((lambda/label->list functions globals ta (- (length text)) d) (car lambdas/labels)))))))

;; (define (functions->text functions globals ta t d)
;;   (let loop ((functions functions) (text '()))
;;     (if (null? functions) text
;;         (loop (cdr functions)
;;               (append '() ;;text
;;                       (function->text functions globals ta t d text (car functions)))))))

;; (define (function->text functions globals ta t d text function)
;;   (format (current-error-port) "elf func=~a\n" (car function))
;;   (let loop ((lambdas/labels (cdr function)) (text text))
;;     (if (null? lambdas/labels) text
;;         (loop (cdr lambdas/labels)
;;               (append '() ;;text
;;                       ((lambda/label->list functions globals ta (- (length text)) d) (car lambdas/labels)))))))

(define (function-prefix name functions)
  (member name (reverse functions) (lambda (a b) (equal? (car b) name))))

(define function-offset
  (let ((cache '()))
    (lambda (name functions)
      (or (assoc-ref cache name)
          (let* ((prefix (function-prefix name functions))
                 (offset (if prefix (length (functions->text (cdr prefix) '() 0 0 0))
                             0)))
            (if (or (equal? name "exit") (> offset 0)) (set! cache (assoc-set! cache name offset)))
            offset)))))

(define (label-offset function label functions)
  (let ((prefix (function-prefix function functions)))
    (if (not prefix) 0
        (let ((function-entry (car prefix)))
          (let loop ((text (cdr function-entry)))
            (if (or (equal? (car text) label) (null? text)) 0
                (let* ((l/l (car text))
                       (t ((lambda/label->list '() '() 0 0 0) l/l))
                       (n (length t)))
                  (+ (loop (cdr text)) n))))))))

(define (globals->data globals)
  (append-map (compose global:value cdr) globals))

(define (data-offset name globals)
  (let* ((prefix (member name (reverse globals)
                         (lambda (a b)
                           (equal? (car b) name)))))
    (if prefix (length (globals->data (cdr prefix)))
        0)))
