;;; -*-scheme-*-

;;; Mes --- Maxwell Equations of Software
;;; Copyright Â© 2016 Jan Nieuwenhuizen <janneke@gnu.org>
;;;
;;; This file is part of Mes.
;;;
;;; Mes is free software; you can redistribute it and/or modify it
;;; under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 3 of the License, or (at
;;; your option) any later version.
;;;
;;; Mes is distributed in the hope that it will be useful, but
;;; WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with Mes.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;;; copy of mes/read-0.mes, comment-out read-input-file

;;; Code:

(begin

  ;; (define car (make-function 'car 0))
  ;; (define cdr (make-function 'cdr 1))
  ;; (define cons (make-function 'cons 1))

  ;; TODO:
  ;; * use case/cond, expand
  ;; * etc int/char?
  ;; * lookup in Scheme
  ;; * read characters, quote, strings

  (define (read)
    (read-word (read-byte) '() (current-module)))

  (define (read-input-file)
    (define (helper x)
      (if (null? x) x
          (cons x (helper (read)))))
    (helper (read)))

  (define-macro (cond . clauses)
    (list 'if (null? clauses) *unspecified*
          (if (null? (cdr clauses))
              (list 'if (car (car clauses))
                    (list (cons 'lambda (cons '() (cons (car (car clauses)) (cdr (car clauses))))))
                    *unspecified*)
              (if (eq? (car (cadr clauses)) 'else)
                  (list 'if (car (car clauses))
                        (list (cons 'lambda (cons '() (car clauses))))
                        (list (cons 'lambda (cons '() (cons *unspecified* (cdr (cadr clauses)))))))
                  (list 'if (car (car clauses))
                        (list (cons 'lambda (cons '() (car clauses))))
                        (cons 'cond (cdr clauses)))))))

  (define (eat-whitespace)
    (cond
     ((eq? (peek-byte) 9) (read-byte) (eat-whitespace))
     ((eq? (peek-byte) 10) (read-byte) (eat-whitespace))
     ((eq? (peek-byte) 13) (read-byte) (eat-whitespace))
     ((eq? (peek-byte) 32) (read-byte) (eat-whitespace))
     ((eq? (peek-byte) 59) (begin (read-line-comment (read-byte))
                                  (eat-whitespace)))
     ((eq? (peek-byte) 35) (begin (read-byte)
                                  (if (eq? (peek-byte) 33) (begin (read-byte)
                                                                  (read-block-comment (read-byte))
                                                                  (eat-whitespace))
                                      (unread-byte 35))))))

  (define (read-block-comment c)
    (if (eq? c 33) (if (eq? (peek-byte) 35) (read-byte)
                       (read-block-comment (read-byte)))
        (read-block-comment (read-byte))))

  ;; (define (read-hex c)
  ;;   (if (eq? c 10) c
  ;;       (read-line-comment (read-byte))))

  (define (read-line-comment c)
    (if (eq? c 10) c
        (read-line-comment (read-byte))))

  (define (read-list a)
    (eat-whitespace)
    (if (eq? (peek-byte) 41) (begin (read-byte) '())
        ((lambda (w)
           (if (eq? w '.) (car (read-list a))
               (cons w (read-list a))))
         (read-word (read-byte) '() a))))

  ;;(define (read-string))

  (define (lookup-char c a)
    (lookup (cons (integer->char c) '()) a))

  (define (read-word c w a)
    (cond
      ((eq? c -1) '())
      ((eq? c 10) (if (null? w) (read-word (read-byte) '() a)
                      (lookup w a)))
      ((eq? c 32) (read-word 10 w a))
      ((eq? c 34) (if (null? w) (read-string)
                      (begin (unread-byte c) (lookup w a))))
      ((eq? c 35) (cond
                   ((eq? (peek-byte) 33) (begin (read-byte)
                                                (read-block-comment (read-byte))
                                                (read-word (read-byte) w a)))
                   ((eq? (peek-byte) 40) (read-byte) (list->vector (read-list a)))
                   ((eq? (peek-byte) 92) (read-byte) (read-character))
                   ((eq? (peek-byte) 120) (read-byte) (read-hex))
                   (else (read-word (read-byte) (append2 w (cons (integer->char c) '())) a))))
      ((eq? c 39) (if (null? w) (cons (lookup (cons (integer->char c) '()) a)
                                      (cons (read-word (read-byte) w a) '()))
                      (begin (unread-byte c) (lookup w a))))
      ((eq? c 40) (if (null? w) (read-list a)
                      (begin (unread-byte c) (lookup w a))))
      ((eq? c 41) (if (null? w) (cons (lookup (cons (integer->char c) '()) a)
                                      (cons (read-word (read-byte) w a) '()))
                      (begin (unread-byte c) (lookup w a))))
      ((eq? c 44) (cond
                   ((eq? (peek-byte) 64) (begin (read-byte)
                                                (cons
                                                 (lookup (symbol->list 'unquote-splicing) a)
                                                 (cons (read-word (read-byte) w a) '()))))
                   (else  (cons (lookup-char c a) (cons (read-word (read-byte) w a)
                                                        '())))))
      ((eq? c 96) (cons (lookup-char c a) (cons (read-word (read-byte) w a) '())))
      ((eq? c 59) (read-line-comment c) (read-word 10 w a))
      (else (read-word (read-byte) (append2 w (cons (integer->char c) '())) a))))

  ;; ((lambda (p)
  ;;    ;;(display 'program=) (display p) (newline)
  ;;    (begin-env p (current-module)))
  ;;  (read-input-file))
  )
