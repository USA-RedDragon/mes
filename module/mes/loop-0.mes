;;; -*-scheme-*-

;;; Mes --- Maxwell Equations of Software
;;; Copyright Â© 2016 Jan Nieuwenhuizen <janneke@gnu.org>
;;;
;;; loop-0.mes: This file is part of Mes.
;;;
;;; Mes is free software; you can redistribute it and/or modify it
;;; under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 3 of the License, or (at
;;; your option) any later version.
;;;
;;; Mes is distributed in the hope that it will be useful, but
;;; WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with Mes.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;;; loop-0.mes - bootstrap into Scheme from minimal -DBOOT=1 core.

;;; When compiling mes.c with -DBOOT=1, eval/apply et al. are lacking
;;; features wrt the fat-c variant, e.g., define and define-macro are
;;; not available; instead label is supplied.  Before loading
;;; boot-0.mes, loop-0.mes is loaded to provide a richer eval/apply.

;;; This might enable moving more functionality from C to Scheme,
;;; making the full source bootstrap process more feasible.  However,
;;; currently performance is 400x worse.  Also several tests in the
;;; test suite fail and the REPL does not work yet.

;;; Code:

((label loop-0
        (lambda (r e a)
          ;; (display "***LOOP-0*** ... e=") (display e) (newline)
          (if (null? e) (eval (read-file (read-env a) a) a)
              (if (atom? e) (loop-0 (eval e a) (read-env a) a)
                  (if (eq? (car e) 'define)
                      ((lambda (aa)     ; env:define
                         ;; (display "0DEFINE name=") (display (cadr e)) (newline)
                         (set-cdr! aa (cdr a))
                         (set-cdr! a aa)
                         (set-cdr! (assq '*closure* a) a)
                         (loop-0 *unspecified* (read-env a) a))
                       (cons            ; sexp:define
                        (if (atom? (cadr e)) (cons (cadr e) (eval (caddr e) a))
                            (cons (caadr e) (eval (cons 'lambda (cons (cdadr e) (cddr e))) a)))
                        '()))
                      (if (eq? (car e) 'define-macro)
                          ((lambda (name+entry) ; env:macro
                             ;; (display "0MACRO name=") (display (car name+entry)) (newline)
                             ((lambda (aa) ; env:define
                                (set-cdr! aa (cdr a))
                                (set-cdr! a aa)
                                (set-cdr! (assq '*closure* a) a)
                                (loop-0 *unspecified* (read-env a) a))
                              (cons
                               (cons (car name+entry)
                                     (make-macro (car name+entry)
                                                 (cdr name+entry)))
                               '())))
                                        ; sexp:define
                           (if (atom? (cadr e)) (cons (cadr e) (eval (caddr e) a))
                               (cons (caadr e) (eval (cons 'lambda (cons (cdadr e) (cddr e))) a)))
                           '())
                          (loop-0 (eval e a) (read-env a) a)))))))
 *unspecified* (read-env '()) (current-module))

()
;; enter reading loop-0
(display "loop-0 ...\n")

(define (evcon c a)
  ;; (display "evcon c=")
  ;; (display c)
  ;; (newline)
  (if (null? c) *unspecified*
      (if (eval-env (caar c) a)
          (if (null? (cdar c) (eval-env (caar c) a))
              (if (null? (cddar c)) (eval-env (cadar c) a)
                  ((lambda ()
                     (eval-env (cadar c) a)
                     (evcon (cons (cons #t (cddar c)) '()) a)))))
          (evcon (cdr c) a))))

(define (not x)
  (if x #f #t))

(define (evlis-env m a)
  (cond
   ((null? m) '())
   ((not (pair? m)) (eval m a))
   (#t (cons (eval (car m) a) (evlis-env (cdr m) a)))))

(define (apply-env fn x a) 
  (cond
   ((atom? fn)
    (cond
     ((builtin? fn) (call fn x))
     ((eq? fn 'call-with-values) (c:apply-env 'call-with-values x a))
     ((eq? fn 'current-module) a)
     (#t (apply-env (eval fn a) x a))))
   ((eq? (car fn) 'lambda)
    ;; (let ((p (pairlis (cadr fn) x a)))
    ;;   (eval (cons 'begin (cddr fn)) (cons (cons '*closure* p)) p))
    (eval (cons 'begin (cddr fn))
              (cons (cons '*closure* (pairlis (cadr fn) x a))
                    (pairlis (cadr fn) x a))))
   ((eq? (car fn) '*closure*)
    ;; (let* ((args (caddr fn))
    ;;        (body (cdddr fn))
    ;;        (a (cddr (cadr fn)))
    ;;        (p (pairlis args x a)))
    ;; (eval (cons 'begin body) (cons (cons '*closure* p) p)))
    (eval (cons 'begin (cdddr fn))
              (cons (cons '*closure* (pairlis (caddr fn) x (cddr (cadr fn))))
                    (pairlis (caddr fn) x (cddr (cadr fn))))))

   ((eq? (car fn) 'label) (apply-env (caddr fn) x (cons (cons (cadr fn) (caddr fn)) a)))
   (#t (apply-env (eval fn a) x a))))

(define (eval-expand e a)
  (cond
   ((internal? e) e)
   ((builtin? e) e)
   ((char? e) e)
   ((number? e) e)
   ((string? e) e)
   ((vector? e) e)
   ((atom? e) (cdr (assq e a)))
   ((atom? (car e))
    (cond
     ((eq? (car e) 'quote) (cadr e))
     ((eq? (car e) 'syntax) (cadr e))
     ((eq? (car e) 'begin) (eval-begin-env e a))
     ((eq? (car e) 'lambda) (make-closure (cadr e) (cddr e) (assq '*closure* a)))
     ((eq? (car e) '*closure*) e)
     ((eq? (car e) 'cond) (evcon (cdr e) a))
     ((eq? (car e) 'if) (eval-if-env (cdr e) a))
     ((eq? (car e) 'define) (env:define (cons (sexp:define e a) '()) a))
     ((eq? (car e) 'define-macro) (env:define (env:macro (sexp:define e a)) a))
     ((eq? (car e) 'set!) (set-env! (cadr e) (eval (caddr e) a) a))
     ((eq? (car e) 'unquote) (eval (cadr e) a))
     ((eq? (car e) 'quasiquote) (eval-quasiquote (cadr e) a))
     (#t (apply-env (car e) (evlis-env (cdr e) a) a))))
   (#t (apply-env (car e) (evlis-env (cdr e) a) a))))

(define (eval e a)
  (eval-expand (expand-macro-env e a) a))

(define (expand-macro-env e a)
  (if (pair? e) ((lambda (macro)
                   (if macro (expand-macro-env (apply-env macro (cdr e) a) a)
                       e))
                 (lookup-macro (car e) a))
      e))

(define (eval-begin-env e a)
  (if (null? e) *unspecified*
      (if (null? (cdr e)) (eval (car e) a)
          (begin
            (eval (car e) a)
            (eval-begin-env (cdr e) a)))))

(define (eval-if-env e a)
  (if (eval (car e) a) (eval (cadr e) a)
      (if (pair? (cddr e)) (eval (caddr e) a))))

(define (sexp:define e a)
  (if (atom? (cadr e)) (cons (cadr e) (eval (caddr e) a))
      (cons (caadr e) (eval (cons 'lambda (cons (cdadr e) (cddr e))) a))))

(define (env:define a+ a)
  (set-cdr! a+ (cdr a))
  (set-cdr! a a+)
  (set-cdr! (assq '*closure* a) a))

(define (env:macro name+entry)
  (cons
   (cons (car name+entry)
         (make-macro (car name+entry)
                     (cdr name+entry)))
   '()))

;; boot into loop-0
(cache-invalidate-range (current-module) '())
()
ignored
