;;; -*-scheme-*-

;;; Mes --- Maxwell Equations of Software
;;; Copyright Â© 2016,2017 Jan Nieuwenhuizen <janneke@gnu.org>
;;;
;;; This file is part of Mes.
;;;
;;; Mes is free software; you can redistribute it and/or modify it
;;; under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 3 of the License, or (at
;;; your option) any later version.
;;;
;;; Mes is distributed in the hope that it will be useful, but
;;; WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with Mes.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;;; libc-i386.mes defines C library routines

;;; Code:

(define (i386:function-preamble)
  '(#x55                                ; push   %ebp
    #x89 #xe5))                         ; mov    %esp,%ebp

(define (i386:function-locals)
  '(#x83 #xec #x20))               ; sub    $0x10,%esp -- 8 local vars

(define (i386:push-global-address o)
  (or o push-global-address)
  `(#x68 ,@(int->bv32 o)))              ; push  $0x<o>

(define (i386:push-global o)
  (or o push-global)
  `(#xa1 ,@(int->bv32 o)                ; mov    0x804a000,%eax
         #x50))                         ; push  %eax

(define (i386:push-local n)
  (or n push-local)
  `(#xff #x75 ,(- 0 (* 4 n))))          ; pushl  0x<n>(%ebp)

(define (i386:push-local-address n)
  (or n push-local-address)
  `(#x8d #x45 ,(- 0 (* 4 n))            ; lea 0x<n>(%ebp),%eax
         #x50))                         ; push %eax

(define (i386:push-local-de-ref n)
  (or n push-local-de-ref)
  `(#x8b #x45 ,(- 0 (* 4 n))            ; mov    -0x<n>(%ebp),%eax
         #x0f #xb6 #x00             	; movzbl (%eax),%eax
         ;;#x0f #xbe #xc0                 ; movsbl %al,%eax ***FIXME BYTE****
         #x50))                         ; push   %eax

(define (i386:pop-accu)
  '(#x58))                              ; pop %eax

(define (i386:push-accu)
  '(#x50))                              ; push %eax

(define (i386:pop-base)
  '(#x5a))                              ; pop %eax

(define (i386:push-base)
  '(#x52))                              ; push %eax

(define (i386:ret . rest)
  (lambda (f g ta t d)
    `(
      ,@(cond ((null? rest) '())
              ((number? (car rest))
               `(#xb8                     ; mov    $<>,%eaxx
                 ,@(int->bv32 (car rest))))
              ((pair? (car rest)) (car rest))
              ((procedure? (car rest))
               ((car rest) f g ta t d)))
    #xc9                                ; leave
    #xc3                                ; ret
    )))

(define (i386:accu->base)
  '(#x89 #xc2))                         ; mov    %eax,%edx

(define (i386:accu->base-address)
  '(#x89 #x02))                         ; mov    %eax,%(edx)

(define (i386:byte-accu->base-address)
  '(#x88 #x02))                         ; mov    %al,%(edx)

(define (i386:accu->base-address+n n)
  (or n accu->base-address+n)
  `(#x89 #x42 ,n))                      ; mov    %eax,$0x<n>%(edx)

(define (i386:accu->local n)
  (or n accu->local)
  `(#x89 #x45 ,(- 0 (* 4 n))))          ; mov    %eax,-<0xn>(%ebp)

(define (i386:base->local n)
  (or n base->local)
  `(#x89 #x55 ,(- 0 (* 4 n))))          ; mov    %edx,-<0xn>(%ebp)

(define (i386:base->global n)
  (or n base->global)
  `(#x89 #x15 ,@(int->bv32 n)))         ; mov    %edx,0x0

(define (i386:accu->global n)
  (or n accu->global)
  `(#xa3 ,@(int->bv32 n)))              ; mov    %eax,0x0

(define (i386:accu->global-address n)
  (or n accu->global-address)
  `(#x8b #x15 ,@(int->bv32 n)           ; mov    0x<n>,%edx
         #x89 #x02 ))                   ; mov    %eax,(%edx)

(define (i386:accu-zero?)
  '(#x85 #xc0))                         ; cmpl   %eax,%eax

(define (i386:accu-non-zero?)
  (append '(#x85 #xc0)                  ; cmpl   %eax,%eax
          (i386:xor-zf)))

(define (i386:accu-shl n)
  (or n accu:shl n)
  `(#xc1 #xe0 ,n))                      ; shl    $0x8,%eax

(define (i386:accu+accu)
  '(#x01 #xc0))                         ; add    %eax,%eax

(define (i386:accu+base)
  `(#x01 #xd0))                         ; add    %edx,%eax

(define (i386:accu+value v)
  (or v accu+value)
  `(#x05 ,@(int->bv32 v)))              ; add    %eax,%eax

(define (i386:accu-base)
  `(#x29 #xd0))                         ; sub    %edx,%eax

(define (i386:accu/base)
  '(#x86 #xd3                           ; mov    %edx,%ebx
    #x31 #xd2                           ; xor    %edx,%edx
    #xf7 #xf3))                         ; div    %ebx

(define (i386:accu%base)
  '(#x86 #xd3                           ; mov    %edx,%ebx
    #x31 #xd2                           ; xor    %edx,%edx
    #xf7 #xf3                           ; div    %ebx
    #x89 #xd0))                         ; mov    %edx,%eax

(define (i386:base->accu)
  '(#x89 #xd0))                         ; mov    %edx,%eax

(define (i386:local->accu n)
  (or n local->accu)
  `(#x8b #x45 ,(- 0 (* 4 n))))          ; mov    -<0xn>(%ebp),%eax

(define (i386:local-address->accu n)
  (or n ladd)
  `(#x8d #x45 ,(- 0 (* 4 n))))          ; lea 0x<n>(%ebp),%eax

(define (i386:local-ptr->accu n)
  (or n local-ptr->accu)
  `(#x89 #xe8                           ; mov    %ebp,%eax
         #x83 #xc0 ,(- 0 (* 4 n))))     ; add    $0x<n>,%eax

(define (i386:byte-local->accu n)
  (or n byte-local->accu)
  `(#x0f #xb6 #x45 ,(- 0 (* 4 n))))     ; movzbl 0x<n>(%ebp),%eax

(define (i386:local->base n)
  (or n local->base)
  `(#x8b #x55 ,(- 0 (* 4 n))))          ; mov    -<0xn>(%ebp),%edx

(define (i386:local-address->base n) ;; DE-REF
  (or n local-address->base)
  `(#x8d #x55 ,(- 0 (* 4 n))))          ; lea    0x<n>(%ebp),%edx

(define (i386:local-ptr->base n)
  (or n local-ptr->base)
  `(#x89 #xea                           ; mov    %ebp,%edx
         #x83 #xc2 ,(- 0 (* 4 n))))     ; add    $0x<n>,%edx

(define (i386:global->base n)
  (or n global->base)
  `(#xba ,@(int->bv32 n)))              ; mov   $<n>,%edx

(define (i386:global-address->accu n)
  (or n global-address->accu)
  `(#xa1 ,@(int->bv32 n)))              ; mov    0x<n>,%eax

(define (i386:global-address->base n)
  (or n global-address->base)
  `(#x8b #x15 ,@(int->bv32 n)))         ; mov    0x<n>,%edx

(define (i386:byte-base-mem->accu)
  '(#x01 #xd0                           ; add    %edx,%eax
         #x0f #xb6 #x00))               ; movzbl (%eax),%eax

(define (i386:byte-mem->accu)
  '(#x0f #xb6 #x00))                    ; movzbl (%eax),%eax

(define (i386:byte-mem->base)
  '(#x0f #xb6 #x10))                    ; movzbl (%eax),%edx

(define (i386:base-mem->accu)
  '(#x01 #xd0                           ; add    %edx,%eax
         #x8b #x00))                    ; mov    (%eax),%eax

(define (i386:mem->accu)
  '(#x8b #x00))                         ; mov    (%eax),%eax

(define (i386:mem+n->accu n)
  `(#x8b #x40 ,n))                      ; mov    0x<n>(%eax),%eax

(define (i386:base-mem+n->accu n)
  (or n base-mem+n->accu)
  `(#x01 #xd0                           ; add    %edx,%eax
         #x8b #x40 ,n))                 ; mov    <n>(%eax),%eax

(define (i386:value->accu v)
  (or v urg:value->accu)
  `(#xb8 ,@(int->bv32 v)))              ; mov    $<v>,%eax

(define (i386:value->accu-address v)
  `(#xc7 #x00 ,@(int->bv32 v)))         ; movl   $0x<v>,(%eax)

(define (i386:value->accu-address+n n v)
  (or v urg:value->accu-address+n)
  `(#xc7 #x40 ,n ,@(int->bv32 v)))      ; movl   $<v>,0x<n>(%eax)

(define (i386:base->accu-address)
  '(#x89 #x10))                         ; mov    %edx,(%eax)

(define (i386:base-address->accu-address)
  '(#x8b #x0a                           ; mov    (%edx),%ecx
    #x89 #x08))                         ; mov    %ecx,(%eax)

(define (i386:accu+n n)
  `(#x83 #xc0 ,n))                      ; add    $0x00,%eax

(define (i386:base+n n)
  `(#x83 #xc2 ,n))                      ; add    $0x00,%edx

(define (i386:byte-base->accu-address)
  '(#x88 #x10))                         ; mov    %dl,(%eax)

(define (i386:byte-base->accu-address+n n)
  (or n byte-base->accu-address+n)
  `(#x88 #x50 ,n))                      ; mov    %dl,0x<n>(%eax)

(define (i386:value->base v)
  (or v urg:value->base)
  `(#xba ,@(int->bv32 v)))              ; mov    $<v>,%edx

(define (i386:local-add n v)
  (or n urg:local-add)
  `(#x83 #x45 ,(- 0 (* 4 n)) ,v))       ; addl   $<v>,0x<n>(%ebp)

(define (i386:global-add n v)
  (or n urg:global-add)
  `(#x83 #x05 ,@(int->bv32 n) ,v))      ; addl   $<v>,0x<n>

(define (i386:global->accu o)
  (or o urg:global->accu)
  `(#xb8 ,@(int->bv32 o)))              ; mov    $<>,%eax

(define (i386:value->global n v)
  (or n value->global)
  `(#xc7 #x05 ,@(int->bv32 n)           ; movl   $<v>,(<n>)
         ,@(int->bv32 v)))

(define (i386:value->local n v)
  (or n value->local)
  `(#xc7 #x45 ,(- 0 (* 4 n))            ; movl   $<v>,0x<n>(%ebp)
         ,@(int->bv32 v)))

(define (i386:local-test n v)
  (or n local-test)
  `(#x83 #x7d ,(- 0 (* 4 n)) ,v))       ; cmpl   $<v>,0x<n>(%ebp)

(define (i386:call f g ta t d address n)
  (or address urg:call)
  `(#xe8 ,@(int->bv32 (- address 5))    ; call   relative $00
         #x83 #xc4 ,(* n 4)))           ; add    $00,%esp

(define (i386:call-accu f g ta t d n)
  `(,@(i386:push-accu)
    ,@(i386:pop-accu)
    #xff #xd0                           ; call   *%eax
    #x83 #xc4 ,(* n 4)))                ; add    $00,%esp

(define (i386:accu-not)
  `(#x0f #x94 #xc0                      ; sete %al
         #x0f #xb6 #xc0))               ; movzbl %al,%eax

(define (i386:xor-accu v)
  (or n urg:xor-accu)
  `(#x35 ,@(int->bv32 v)))       	;xor    $0xff,%eax

(define (i386:xor-zf)
  '(#x9f                                ; lahf   
    #x80 #xf4 #x40                      ; xor    $0x40,%ah
    #x9e))                              ; sahf   

(define (i386:accu-cmp-value v)
  `(#x83 #xf8 ,v))                      ; cmp    $<v>,%eax

(define (i386:accu-test)
  '(#x85 #xc0))                         ; test   %eax,%eax

(define (i386:Xjump n)
  (or n urg:Xjump)
  `(#xe9 ,@(int->bv32 (if (>= n 0) n (- n 5))))) ; jmp . + <n>

(define (i386:XXjump n)
  (or n urg:XXjump)
  `(#xe9 ,@(int->bv32 n)))              ; jmp . + <n>

(define (i386:Xjump-nz n)
  (or n urg:Xjump-nz)
  `(#x0f #x85 ,@(int->bv32 n)))         ; jnz . + <n>

(define (i386:Xjump-z n)
  (or n urg:Xjump-z)
  `(#x0f #x84 ,@(int->bv32 n)))         ; jz . + <n>

(define (i386:jump n) ;;FIXME: NEED THIS WEIRDNESS for t.c
  (when (or (> n #x80) (< n #x-80))
    (format (current-error-port) "JUMP n=~a\n" n)
    barf)
  `(#xeb ,(if (>= n 0) (- n 2) (- n 2)))) ; jmp <n>

(define (i386:jump-c n)
  (when (or (> n #x80) (< n #x-80))
    (format (current-error-port) "JUMP n=~a\n" n)
    barf)
  `(#x72 ,(if (>= n 0) n (- n 2))))     ; jc <n>

(define (i386:Xjump-c n)
  (or n urg:Xjump-c)
  `(#x0f #x82 ,@(int->bv32 n)))     ; jc <n>

(define (i386:jump-cz n)
  (when (or (> n #x80) (< n #x-80))
    (format (current-error-port) "JUMP n=~a\n" n)
    barf)
  `(#x76 ,(if (>= n 0) n (- n 2))))     ; jna <n>

(define (i386:jump-ncz n)
  (when (or (> n #x80) (< n #x-80))
    (format (current-error-port) "JUMP-ncz n=~a\n" n)
    barf)
  `(#x77 ,(if (>= n 0) n (- n 2))))     ; ja <n>

(define (i386:jump-nc n)
  (when (or (> n #x80) (< n #x-80))
    (format (current-error-port) "JUMP-nc n=~a\n" n)
    barf)
  `(#x73 ,(if (>= n 0) n (- n 2))))     ; jnc <n>

(define (i386:Xjump-nc n)
  (or n urg:Xjump-nc)
  `(#x0f #x83 ,@(int->bv32 n)))         ; jnc <n>

(define (i386:jump-z n)
  (when (or (> n #x80) (< n #x-80))
    (format (current-error-port) "JUMP-z n=~a\n" n)
    barf)
  `(#x74 ,(if (>= n 0) n (- n 2)))) ; jz <n>

(define (i386:jump-nz n)
  (when (or (> n #x80) (< n #x-80))
    (format (current-error-port) "JUMP-nz n=~a\n" n)
    barf)
  `(#x75 ,(if (>= n 0) n (- n 2)))) ; jnz <n>

(define (i386:test-jump-z n)
  (when (or (> n #x80) (< n #x-80))
    (format (current-error-port) "JUMP-z n=~a\n" n)
    barf)
  `(#x85 #xc0                           ; test   %eax,%eax
    #x74 ,(if (>= n 0) n (- n 4))))     ; jz <n>

(define (i386:jump-byte-nz n)
  (when (or (> n #x80) (< n #x-80))
    (format (current-error-port) "JUMP-byte-nz n=~a\n" n)
    barf)
  `(#x84 #xc0                           ; test   %al,%al
    #x75 ,(if (>= n 0) n (- n 4))))     ; jne <n>

(define (i386:jump-byte-z n)
  (when (or (> n #x80) (< n #x-80))
    (format (current-error-port) "JUMP-byte-z n=~a\n" n)
    barf)
  `(#x84 #xc0                           ; test   %al,%al
    #x74 ,(if (>= n 0) n (- n 4))))     ; jne <n>

(define (i386:byte-test-base)
  `(#x38 #xc2))                         ; cmp    %al,%dl

(define (i386:test-base)
  `(#x39 #xd0))                         ; cmp    %edx,%eax

(define (i386:byte-sub-base)
  `(#x28 #xd0))                         ; sub    %dl,%al

(define (i386:byte-base-sub)
  `(#x28 #xd0))                         ; sub    %al,%dl

(define (i386:sub-base)
  `(#x29 #xd0))                         ; sub    %edx,%eax

(define (i386:base-sub)
  `(#x29 #xc2))                         ; sub    %eax,%edx

;;; libc bits
(define (i386:exit f g ta t d)
  `(
    #x5b                                ; pop    %ebx
    #x5b                                ; pop    %ebx
    #xb8 #x01 #x00 #x00 #x00            ; mov    $0x1,%eax
    #xcd #x80                           ; int    $0x80
    ))

(define (i386:open f g ta t d)
  `(
    #x55                                ; push   %ebp
    #x89 #xe5                           ; mov    %esp,%ebp

    #x8b #x5d #x08                      ; mov    0x8(%ebp),%ebx
    #x8b #x4d #x0c                      ; mov    0xc(%ebp),%ecx

    #xb8 #x05 #x00 #x00 #x00            ; mov    $0x5,%eax
    #xcd #x80                           ; int    $0x80

    #xc9                                ; leave
    #xc3                                ; ret
    ))

(define (i386:read f g ta t d)
  `(
    #x55                                ; push   %ebp
    #x89 #xe5                           ; mov    %esp,%ebp

    #x8b #x5d #x08                      ; mov    0x8(%ebp),%ebx
    #x8b #x4d #x0c                      ; mov    0xc(%ebp),%ecx
    #x8b #x55 #x10                      ; mov    0x10(%ebp),%edx

    #xb8 #x03 #x00 #x00 #x00            ; mov    $0x3,%eax
    #xcd #x80                           ; int    $0x80

    #xc9                                ; leave
    #xc3                                ; ret
    ))

(define (i386:write f g ta t d)
  `(
    #x55                                ; push   %ebp
    #x89 #xe5                           ; mov    %esp,%ebp

    #x8b #x5d #x08                      ; mov    0x8(%ebp),%ebx
    #x8b #x4d #x0c                      ; mov    0xc(%ebp),%ecx
    #x8b #x55 #x10                      ; mov    0x10(%ebp),%edx

    #xb8 #x04 #x00 #x00 #x00            ; mov    $0x4,%eax
    #xcd #x80                           ; int    $0x80

    #xc9                                ; leave
    #xc3                                ; ret
    ))

#!
08048121 <strcmp>:
 8048121:	55                   	push   %ebp
 8048122:	89 e5                	mov    %esp,%ebp
 8048124:	83 ec 10             	sub    $0x10,%esp
 8048127:	eb 08                	jmp    8048131 <strcmp+0x10>

<body>
 8048129:	83 45 08 01          	addl   $0x1,0x8(%ebp)
 804812d:	83 45 0c 01          	addl   $0x1,0xc(%ebp)

<test> *a
 8048131:	8b 45 08             	mov    0x8(%ebp),%eax
 8048134:	0f b6 00             	movzbl (%eax),%eax
 8048137:	84 c0                	test   %al,%al
 8048139:	74 08                	je     8048143 <strcmp+0x22>

<test1> *b
 804813b:	8b 45 0c             	mov    0xc(%ebp),%eax
 804813e:	0f b6 00             	movzbl (%eax),%eax
 8048141:	84 c0                	test   %al,%al
 8048143:	74 10                	je     8048155 <strcmp+0x34>

<test2> *a == *b
 8048145:	8b 45 08             	mov    0x8(%ebp),%eax
 8048148:	0f b6 10             	movzbl (%eax),%edx
 804814b:	8b 45 0c             	mov    0xc(%ebp),%eax
 804814e:	0f b6 00             	movzbl (%eax),%eax
 8048151:	38 c2                	cmp    %al,%dl
 8048153:	84 c0                	test   %al,%al
 8048155:	75 d2                	jne    8048129 <strcmp+0x8>


 8048157:	8b 45 08             	mov    0x8(%ebp),%eax
 804815a:	0f b6 10             	movzbl (%eax),%edx
 804815d:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048160:	0f b6 00             	movzbl (%eax),%eax
 8048163:	28 d0                	sub    %dl,%al
 8048165:	c9                   	leave
 8048166:	c3                   	ret  
!#
