;;; -*-scheme-*-

;;; Mes --- Maxwell Equations of Software
;;; Copyright Â© 2016,2017 Jan Nieuwenhuizen <janneke@gnu.org>
;;;
;;; This file is part of Mes.
;;;
;;; Mes is free software; you can redistribute it and/or modify it
;;; under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 3 of the License, or (at
;;; your option) any later version.
;;;
;;; Mes is distributed in the hope that it will be useful, but
;;; WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with Mes.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;;; compiler.mes produces an i386 binary from the C produced by
;;; Nyacc c99.

;;; Code:

(cond-expand
 (guile)
 (guile-2)
 (mes
  (mes-use-module (srfi srfi-1))))

(define (functions->lambdas functions)
  (append-map cdr functions))

(define (lambda/label->list f g t d)
  (lambda (l/l)
    (if (not (procedure? l/l)) '() (l/l f g t d))))

(define (text->list o)
  (append-map (lambda/label->list '() '() 0 0) o))

(define (functions->text functions globals t d)
  (let loop ((lambdas/labels (functions->lambdas functions)) (text '()))
    (if (null? lambdas/labels) text
        (loop (cdr lambdas/labels)
              (append text ((lambda/label->list functions globals (- (length text)) d) (car lambdas/labels)))))))

(define (function-prefix name functions)
  (member name (reverse functions) (lambda (a b) (equal? (car b) name))))

(define (function-offset name functions)
  (let ((prefix (function-prefix name functions)))
    (if prefix (length (functions->text (cdr prefix) '() 0 0))
        0)))

(define (label-offset function label functions)
  (let ((prefix (function-prefix function functions)))
    (if (not prefix) 0
        (let ((function-entry (car prefix)))
          (let loop ((text (cdr function-entry)))
            (if (or (equal? (car text) label) (null? text)) 0
                (let* ((l/l (car text))
                       (t ((lambda/label->list '() '() 0 0) l/l))
                       (n (length t)))
                  (+ (loop (cdr text)) n))))))))

(define (globals->data globals)
  (append-map cdr globals))

(define (data-offset name globals)
  (let* ((prefix (member name (reverse globals)
                         (lambda (a b)
                           (equal? (car b) name)))))
    (if prefix (length (globals->data (cdr prefix)))
        0)))
