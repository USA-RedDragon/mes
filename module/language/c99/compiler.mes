;;; -*-scheme-*-

;;; Mes --- Maxwell Equations of Software
;;; Copyright Â© 2016,2017,2018 Jan Nieuwenhuizen <janneke@gnu.org>
;;;
;;; This file is part of Mes.
;;;
;;; Mes is free software; you can redistribute it and/or modify it
;;; under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 3 of the License, or (at
;;; your option) any later version.
;;;
;;; Mes is distributed in the hope that it will be useful, but
;;; WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with Mes.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;;; compiler.mes produces an i386 binary from the C produced by
;;; Nyacc c99.

;;; Code:

(cond-expand
 (guile-2)
 (guile)
 (mes
  (mes-use-module (srfi srfi-1))
  (mes-use-module (srfi srfi-26))
  (mes-use-module (mes pmatch))
  (mes-use-module (nyacc lang c99 parser))
  (mes-use-module (nyacc lang c99 pprint))
  (mes-use-module (mes as))
  (mes-use-module (mes as-i386))
  (mes-use-module (mes M1))
  (mes-use-module (mes optargs))
  (mes-use-module (language c99 info))))

(define (logf port string . rest)
  (apply format (cons* port string rest))
  (force-output port)
  #t)

(define (stderr string . rest)
  (apply logf (cons* (current-error-port) string rest)))

(define (pke . stuff)
  (newline (current-error-port))
  (display ";;; " (current-error-port))
  (write stuff (current-error-port))
  (newline (current-error-port))
  (car (last-pair stuff)))

(define (pke . stuff)
  (car (last-pair stuff)))

(define %prefix (if (string-prefix? "@PREFIX" "@PREFIX@") (or (getenv "PREFIX") "") "@PREFIX@"))

(define mes? (pair? (current-module)))

(define* (c99-input->full-ast #:key (defines '()) (includes '()))
  (let ((sys-include (if (equal? %prefix "") "include" (string-append %prefix "/share/include"))))
    (parse-c99
     #:inc-dirs (append includes (cons* sys-include "include" "lib" (or (and=> (getenv "C_INCLUDE_PATH") (cut string-split <> #\:)) '())))
     #:cpp-defs `(
                  "NULL=0"
                  "__linux__=1"
                  "__i386__=1"
                  "POSIX=0"
                  "_POSIX_SOURCE=0"
                  "__MESC__=1"
                  ,(if mes? "__MESC_MES__=1" "__MESC_MES__=0")
                  ,@defines)
     #:mode 'code)))

(define (ast-strip-comment o)
  (pmatch o
    ((comment . ,comment) #f)
    (((comment . ,comment) . ,t) (filter-map ast-strip-comment t))
    (((comment . ,comment) . ,cdr) cdr)
    ((,car . (comment . ,comment)) car)
    ((,h . ,t) (if (list? o) (filter-map ast-strip-comment o)
                   (cons (ast-strip-comment h) (ast-strip-comment t))))
    (_  o)))

(define (ast-strip-const o)
  (pmatch o
    ((type-qual ,qual) (if (equal? qual "const") #f o))
    ((pointer (type-qual-list (type-qual ,qual)) . ,rest)
     (if (equal? qual "const") `(pointer ,@rest) o))
    ((decl-spec-list (type-qual ,qual))
     (if (equal? qual "const") #f
         `(decl-spec-list (type-qual ,qual))))
    ((decl-spec-list (type-qual ,qual) . ,rest)
     (if (equal? qual "const") `(decl-spec-list ,@rest)
         `(decl-spec-list (type-qual ,qual) ,@(map ast-strip-const rest))))
    ((decl-spec-list (type-qual-list (type-qual ,qual)) . ,rest)
     (if (equal? qual "const") `(decl-spec-list ,@rest)
         `(decl-spec-list (type-qual-list (type-qual ,qual)) ,@(map ast-strip-const rest))))
    ((,h . ,t) (if (list? o) (filter-map ast-strip-const o)
                   (cons (ast-strip-const h) (ast-strip-const t))))
    (_  o)))

(define (ast:function? o)
  (and (pair? o) (eq? (car o) 'fctn-defn)))

(define (.name o)
  (pmatch o
    ((fctn-defn _ (ftn-declr (ident ,name) _) _) name)
    ((fctn-defn _ (ptr-declr (pointer) (ftn-declr (ident ,name) _)) _) name)
    ((fctn-defn _ (ptr-declr (pointer (pointer)) (ftn-declr (ident ,name) _)) _) name)
    ((ellipsis) #f)
    ((param-decl (decl-spec-list (type-spec (void)))) #f)
    ((param-decl _ (param-declr (ident ,name))) name)
    ((param-decl _ (param-declr (ptr-declr (pointer) (ident ,name)))) name)
    ((param-decl _ (param-declr (ptr-declr (pointer) (array-of (ident ,name))))) name)
    ((param-decl _ (param-declr (ptr-declr (pointer (pointer)) (ident ,name)))) name)
    ((param-decl _ (param-declr (ptr-declr (pointer (pointer (pointer))) (ident ,name)))) name)
    ((param-decl _ (param-declr (ptr-declr (pointer (decl-spec-list) (pointer)) (ident ,name)))) name)
    ((param-decl _ (param-declr (ptr-declr (pointer (decl-spec-list)) (array-of (ident ,name))))) name)
    ((param-decl _ (param-declr (ftn-declr (scope (ptr-declr (pointer) (ident ,name))) (param-list . ,params)))) name)
    (_
     (format (current-error-port) "SKIP: .name =~a\n" o))))

(define (.type o)
  (pmatch o
    ((ellipsis) #f)
    ((param-decl (decl-spec-list (type-spec (void)))) #f)
    ((param-decl (decl-spec-list (type-spec ,type)) _) (decl->ast-type type))
    ((param-decl ,type _) type)
    (_
     (format (current-error-port) "SKIP: .type =~a\n" o))))

(define (.statements o)
  (pmatch o
    ((fctn-defn _ (ftn-declr (ident ,name) _) (compd-stmt (block-item-list . ,statements))) statements)
    ((fctn-defn _ (ptr-declr (pointer) (ftn-declr (ident ,name) _)) (compd-stmt (block-item-list . ,statements))) statements)
    ((fctn-defn _ (ptr-declr (pointer (pointer)) (ftn-declr (ident ,name) _)) (compd-stmt (block-item-list . ,statements))) statements)
    (_ (error ".statements: unsupported: " o))))

(define (clone o . rest)
  (cond ((info? o)
         (let ((types (.types o))
               (constants (.constants o))
               (functions (.functions o))
               (globals (.globals o))
               (locals (.locals o))
               (function (.function o))
               (text (.text o))
               (break (.break o))
               (continue (.continue o)))
           (let-keywords rest
                         #f
                         ((types types)
                          (constants constants)
                          (functions functions)
                          (globals globals)
                          (locals locals)
                          (function function)
                          (text text)
                          (break break)
                          (continue continue))
                         (make <info> #:types types #:constants constants #:functions functions #:globals globals  #:locals locals #:function function #:text text #:break break #:continue continue))))))

(define (ident->constant name value)
  (cons name value))

(define (enum->type-entry name fields)
  (cons `("tag" ,name) (make-type 'enum 4 0 fields)))

(define (struct->type-entry name fields)
  (cons `("tag" ,name) (make-type 'struct (apply + (map field:size fields)) 0 fields)))

(define (union->type-entry name fields)
  (cons `("tag" ,name) (make-type 'union (apply + (map field:size fields)) 0 fields)))

(define i386:type-alist
  `(("char" . ,(make-type 'builtin 1 0 #f))
    ("short" . ,(make-type 'builtin 2 0 #f))
    ("int" . ,(make-type 'builtin 4 0 #f))
    ("long" . ,(make-type 'builtin 4 0 #f))
    ;;("long long" . ,(make-type 'builtin 8 0 #f))
    ;;("long long int" . ,(make-type 'builtin 8 0 #f))

    ("long long" . ,(make-type 'builtin 4 0 #f))  ;; FIXME
    ("long long int" . ,(make-type 'builtin 4 0 #f))

    ("void" . ,(make-type 'builtin 1 0 #f))
    ;; FIXME sign
    ("unsigned char" . ,(make-type 'builtin 1 0 #f))
    ("unsigned short" . ,(make-type 'builtin 2 0 #f))
    ("unsigned short int" . ,(make-type 'builtin 2 0 #f))
    ("unsigned" . ,(make-type 'builtin 4 0 #f))
    ("unsigned int" . ,(make-type 'builtin 4 0 #f))
    ("unsigned long" . ,(make-type 'builtin 4 0 #f))

    ;; ("unsigned long long" . ,(make-type 'builtin 8 0 #f))
    ;; ("unsigned long long int" . ,(make-type 'builtin 8 0 #f))
    ("unsigned long long" . ,(make-type 'builtin 4 0 #f)) ;; FIXME
    ("unsigned long long int" . ,(make-type 'builtin 4 0 #f))
    ))

(define (field:name o)
  (pmatch o
    ((struct (,name ,type ,size ,pointer) . ,rest) name)
    ((union (,name ,type ,size ,pointer) . ,rest) name)
    ((,name ,type ,size ,pointer) name)
    (_ (error "field:name not supported:" o))))

(define (field:pointer o)
  (pmatch o
    ((struct (,name ,type ,size ,pointer) . ,rest) pointer)
    ((union (,name ,type ,size ,pointer) . ,rest) pointer)
    ((,name ,type ,size ,pointer) pointer)
    (_ (error "field:name not supported:" o))))

(define (field:size o)
  (pmatch o
    ((struct . ,fields) (apply + (map field:size fields)))
    ((union . ,fields) (apply max (map field:size fields)))
    ((,name ,type ,size ,pointer) size)
    (_ (error (format #f "field:size: ~s\n" o)))))

(define (field:type o)
  (pmatch o
    ((,name ,type ,size ,pointer) type)
    (_ (error (format #f "field:type: ~s\n" o)))))

(define (get-type types o)
  (let ((t (assoc-ref types o)))
    (pmatch t
      ((typedef ,next) (get-type types next))
      (_ t))))

(define (ast-type->type info o)
  (pmatch o
    ((p-expr ,expr) (ast-type->type info (expr->type info o)))
    ((pre-inc ,expr) (ast-type->type info expr))
    ((post-inc ,expr) (ast-type->type info expr))
    ((decl-spec-list ,type-spec)
     (ast-type->type info type-spec))
    ((decl-spec-list (type-qual ,qual) (type-spec (fixed-type ,type)))
     (ast-type->type info type))
    ((array-ref ,index (p-expr (ident ,array)))
     (ast-type->type info `(p-expr (ident ,array))))
    ((struct-ref (ident ,type))
     (or (get-type (.types info) type)
         (let ((struct (if (pair? type) type `("tag" ,type))))
           (ast-type->type info struct))))
    ((union-ref (ident ,type))
     (or (get-type (.types info) type)
         (let ((struct (if (pair? type) type `("tag" ,type))))
           (ast-type->type info struct))))
    ((void) (ast-type->type info "void"))
    ((type-spec ,type) (ast-type->type info type))
    ((fixed-type ,type) (ast-type->type info type))
    ((typename ,type) (ast-type->type info type))
    ((de-ref ,expr)
     (ast-type->type info expr))
    ((d-sel (idend ,field) ,struct)
     (let ((type0 (ast-type->type info struct)))
       (field-type info type0 field)))
    ((i-sel (ident ,field) ,struct)
     (let ((type0 (ast-type->type info struct)))
       (field-type info type0 field)))
    (_ (let ((type (get-type (.types info) o)))
         (if type type
             (begin
               (stderr "types: ~s\n" (.types info))
               (error "ast-type->type: unsupported: " o)))))))

(define (ast-type->description info o)
  (let* ((type (ast-type->type info o))
         (xtype (if (type? type) type
                    (ast-type->type info type))))
    (type:description xtype)))

(define (ast-type->size info o)
  (let* ((type (ast-type->type info o))
         (xtype (if (type? type) type
                    (ast-type->type info type))))
    (type:size xtype)))

(define (field-field info struct field)
  (let* ((xtype (if (type? struct) struct
                    (ast-type->type info struct)))
         (fields (type:description xtype)))
    (let loop ((fields fields))
      (if (null? fields) (error (format #f "no such field: ~a in ~s" field struct))
          (let ((f (car fields)))
            (cond ((equal? (car f) field) f)
                  ((and (memq (car f) '(struct union))
                        (find (lambda (x) (equal? (car x) field)) (cdr f))))
                  (else (loop (cdr fields)))))))))

(define (field-offset info struct field)
  (let ((xtype (if (type? struct) struct
                    (ast-type->type info struct))))
    (if (eq? (type:type xtype) 'union) 0
        (let ((fields (type:description xtype)))
          (let loop ((fields fields) (offset 0))
            (if (null? fields) (error (format #f "no such field: ~a in ~s" field struct))
                (let ((f (car fields)))
                  (cond ((equal? (car f) field) offset)
                        ((and (eq? (car f) 'struct)
                              (find (lambda (x) (equal? (car x) field)) (cdr f))
                              (apply + (cons offset
                                             (map field:size
                                                  (member field (reverse (cdr f))
                                                          (lambda (a b)
                                                            (equal? a (car b) field))))))))
                        ((and (eq? (car f) 'union)
                              (find (lambda (x) (equal? (car x) field)) (cdr f))
                              offset))
                        (else (loop (cdr fields) (+ offset (field:size f))))))))))))

(define (field-pointer info struct field)
  (let ((field (field-field info struct field)))
    (field:pointer field)))

(define (field-size info struct field)
  (let ((xtype (if (type? struct) struct
                   (ast-type->type info struct))))
    (if (eq? (type:type xtype) 'union) 0
        (let ((field (field-field info struct field)))
          (field:size field)))))

(define (field-type info struct field)
  (let ((field (field-field info struct field)))
    (field:type field)))

(define (ast->type o)
  (pmatch o
    ((fixed-type ,type)
     type)
    ((typename ,type)
     type)
    ((struct-ref (ident ,type))
     `("tag" ,type))
    (_ (stderr "SKIP: type=~s\n" o)
       "int")))

(define (decl->ast-type o)
  (pmatch o
    ((fixed-type ,type) type)
    ((struct-ref (ident (,name))) `("tag" ,name))
    ((struct-ref (ident ,name)) `("tag" ,name))
    ((struct-def (ident ,name) . ,fields) `("tag" ,name))
    ((decl (decl-spec-list (type-spec (struct-ref (ident ,name))))) ;; "scm"
     `("tag" ,name)) ;; FIXME
    ((typename ,name) name)
    (,name name)
    (_ (error "decl->ast-type: unsupported: " o))))

(define (byte->hex.m1 o)
  (string-drop o 2))

(define (asm->m1 o)
  (let ((prefix ".byte "))
    (if (not (string-prefix? prefix o)) (map (cut string-split <> #\space) (string-split o #\newline))
        (let ((s (string-drop o (string-length prefix))))
          (list (format #f "'~a'" (string-join (map byte->hex.m1 (cdr (string-split o #\space))) " ")))))))

(define (ident->decl info o)
  (or (assoc-ref (.locals info) o)
      (assoc-ref (.globals info) o)
      (assoc-ref (.constants info) o)
      (begin
        (stderr "NO IDENT: ~a\n" o)
        (assoc-ref (.functions info) o))))

(define (ident->type info o)
  (let ((type (ident->decl info o)))
    (cond ((global? type) (global:type type))
          ((local? type) (local:type type))
          ((assoc-ref (.constants info) o) "int")
          (else (stderr "ident->type ~s => ~s\n" o type)
                (car type)))))

(define (ident->pointer info o)
  (let ((local (assoc-ref (.locals info) o)))
    (if local (local:pointer local)
        (let ((global (assoc-ref (.globals info) o)))
          (if global
              (global:pointer (ident->decl info o))
              0)))))

(define (ident->type-size info o)
  (let* ((type (ident->type info o))
         (xtype (ast-type->type info type)))
    (type:size xtype)))

(define (ptr-inc o)
  (if (< o 0) (1- o)
      (1+ o)))

(define (ptr-dec o)
  (if (< o 0) (1+ o)
      (1- o)))

(define (expr->pointer info o)
  (pmatch o
    ((pointer) 1)
    ((p-expr (char ,value)) 0)
    ((p-expr (fixed ,value)) 0)
    ((p-expr (ident ,name)) (ident->pointer info name))
    ((de-ref ,expr) (ptr-dec (expr->pointer info expr)))
    ((assn-expr ,lhs ,op ,rhs) (expr->pointer info lhs))
    ((add ,a ,b) (expr->pointer info a))
    ((div ,a ,b) (expr->pointer info a))
    ((mod ,a ,b) (expr->pointer info a))
    ((mul ,a ,b) (expr->pointer info a))
    ((sub ,a ,b) (expr->pointer info a))
    ((neg ,a) (expr->pointer info a))
    ((pre-inc ,a) (expr->pointer info a))
    ((pre-dec ,a) (expr->pointer info a))
    ((post-inc ,a) (expr->pointer info a))
    ((post-dec ,a) (expr->pointer info a))
    ((ref-to ,expr) (ptr-inc (expr->pointer info expr)))
    ((array-ref ,index ,array) (ptr-dec (expr->pointer info array)))

    ((d-sel (ident ,field) ,struct)
       (let ((type (expr->type info struct)))
         (field-pointer info type field)))

    ((i-sel (ident ,field) ,struct)
       (let ((type (expr->type info struct)))
         (field-pointer info type field)))

    ((cast (type-name ,type) ,expr)     ; FIXME: add expr?
     (let* ((type (ast-type->type info type))
            (pointer (type:pointer type)))
       pointer))
    ((cast (type-name ,type (abs-declr ,pointer)) ,expr) ; FIXME: add expr?
     (let* ((type (ast-type->type info type))
            (pointer0 (type:pointer type))
            (pointer1 (ptr-declr->pointer pointer))
            (pointer2 (expr->pointer info expr)))
       (+ pointer0 pointer1)))
    (_ (stderr "expr->pointer: unsupported: ~s\n" o) 0)))

(define %int-size 4)
(define %pointer-size %int-size)

(define (expr->type-size info o)
  (pmatch o
    ((p-expr (char ,value)) 1)
    ((p-expr (fixed ,name)) %int-size)
    ((p-expr (ident ,name)) (ident->type-size info name))

    ((array-ref ,index ,array)
     (let ((type (expr->type info array)))
       (ast-type->size info type)))

    ((d-sel (ident ,field) ,struct)
     (let* ((type (expr->type info struct))
            (type (field-type info type field)))
       (ast-type->size info type)))

    ((i-sel (ident ,field) ,struct)
     (let* ((type (expr->type info struct))
            (type (field-type info type field)))
       (ast-type->size info type)))

    ((de-ref ,expr) (expr->type-size info expr))
    ((ref-to ,expr) (expr->type-size info expr))
    ((add ,a ,b) (expr->type-size info a))
    ((div ,a ,b) (expr->type-size info a))
    ((mod ,a ,b) (expr->type-size info a))
    ((mul ,a ,b) (expr->type-size info a))
    ((sub ,a ,b) (expr->type-size info a))
    ((neg ,a) (expr->type-size info a))
    ((pre-inc ,a) (expr->type-size info a))
    ((pre-dec ,a) (expr->type-size info a))
    ((post-inc ,a) (expr->type-size info a))
    ((post-dec ,a) (expr->type-size info a))
    ((cast (type-name ,type) ,expr)     ; FIXME: ignore expr?
     (let ((type (ast-type->type info type)))
       (type:size type)))
    ((cast (type-name ,type (abs-declr ,pointer)) ,expr) ; FIXME: ignore expr?
     (let ((type (ast-type->type info type)))
       (type:size type)))
    (_ (stderr "expr->type-size: unsupported: ~s\n" o) 4)))

(define (expr->size info o)
  (let ((ptr (expr->pointer info o)))
    (if (or (= ptr -1)
            (= ptr 0))
        (expr->type-size info o)
        %pointer-size)))

(define (expr->type info o)
  (pmatch o
    ((p-expr (char ,name)) "char")
    ((p-expr (fixed ,value)) "int")
    ((p-expr (ident ,name)) (ident->type info name))
    ((array-ref ,index ,array)
     (expr->type info array))

    ((i-sel (ident ,field) ,struct)
     (let ((type (expr->type info struct)))
       (field-type info type field)))

    ((d-sel (ident ,field) ,struct)
     (let ((type (expr->type info struct)))
       (field-type info type field)))    
    
    ((de-ref ,expr) (expr->type info expr))
    ((ref-to ,expr) (expr->type info expr))
    ((add ,a ,b) (expr->type info a))
    ((div ,a ,b) (expr->type info a))
    ((mod ,a ,b) (expr->type info a))
    ((mul ,a ,b) (expr->type info a))
    ((sub ,a ,b) (expr->type info a))
    ((neg ,a) (expr->type info a))
    ((pre-inc ,a) (expr->type info a))
    ((pre-dec ,a) (expr->type info a))
    ((post-inc ,a) (expr->type info a))
    ((post-dec ,a) (expr->type info a))
    ((cast (type-name ,type) ,expr) ; FIXME: ignore expr?
     type)
    ((cast (type-name ,type (abs-declr ,pointer)) ,expr) ; FIXME: ignore expr?
     type)
    ((fctn-call (p-expr (ident ,name)))
     (stderr "TODO: expr->type: unsupported: ~s\n" o)
     "int")
    (_ ;;(error (format #f "expr->type: unsupported: ~s") o)
     (stderr "TODO: expr->type: unsupported: ~s\n" o)
     "int")))

(define (append-text info text)
  (clone info #:text (append (.text info) text)))

(define (push-global info)
  (lambda (o)
    (let ((ptr (ident->pointer info o)))
      (cond ((< ptr 0) (list (i386:push-label `(#:address ,o))))
            (else (list (i386:push-label-mem `(#:address ,o))))))))

(define (push-local locals)
  (lambda (o)
    (wrap-as (i386:push-local (local:id o)))))

(define (push-global-address info)
  (lambda (o)
    (list (i386:push-label o))))

(define (push-local-address locals)
  (lambda (o)
    (wrap-as (i386:push-local-address (local:id o)))))

(define push-global-de-ref push-global)

(define (push-local-de-ref info)
  (lambda (o)
    (let* ((local o)
           (ptr (local:pointer local))
           (size (if (= ptr 1) (ast-type->size info (local:type o))
                     4)))
      (case size
        ((1) (wrap-as (i386:push-byte-local-de-ref (local:id o))))
        ((2) (wrap-as (i386:push-word-local-de-ref (local:id o))))
        ((4) (wrap-as (i386:push-local-de-ref (local:id o))))
        (else (error (format #f "TODO: push size >4: ~a\n" size)))))))

(define (push-local-de-de-ref info)
  (lambda (o)
    (let* ((local o)
           (ptr (local:pointer local))
           (size (if (= ptr 2) (ast-type->size info (local:type o));; URG
                     4)))
      (if (= size 1)
          (wrap-as (i386:push-byte-local-de-de-ref (local:id o)))
          (error "TODO int-de-de-ref")))))

(define (make-global-entry key type pointer value)
  (cons key (make-global type pointer value)))

(define (string->global-entry string)
  (make-global-entry `(#:string ,string) "string" 0 (append (string->list string) (list #\nul))))

(define (int->global-entry value)
  (make-global-entry (number->string value) "int" 0 (int->bv32 value)))

(define (ident->global-entry name type pointer value)
  (make-global-entry name type pointer (if (pair? value) value (int->bv32 value))))

(define (make-local-entry name type pointer id)
  (cons name (make-local type pointer id)))

(define* (mescc:trace name #:optional (type ""))
  (format (current-error-port) "    :~a~a\n" name type))

(define (push-ident info)
  (lambda (o)
    (let ((local (assoc-ref (.locals info) o)))
      (if local
          (begin
            (let* ((ptr (local:pointer local)))
             (if (or (< ptr 0)) ((push-local-address (.locals info)) local)
                 ((push-local (.locals info)) local))))
          (let ((global (assoc-ref (.globals info) o)))
            (if global
                ((push-global info) o) ;; FIXME: char*/int
                (let ((constant (assoc-ref (.constants info) o)))
                  (if constant
                      (wrap-as (append (i386:value->accu constant)
                                       (i386:push-accu)))
                      ((push-global-address #f) `(#:address ,o))))))))))

(define (push-ident-address info)
  (lambda (o)
    (let ((local (assoc-ref (.locals info) o)))
      (if local ((push-local-address (.locals info)) local)
          (let ((global (assoc-ref (.globals info) o)))
          (if global
              ((push-global-address info) o)
              ((push-global-address #f) `(#:address ,o))))))))

(define (push-ident-de-ref info)
  (lambda (o)
    (let ((local (assoc-ref (.locals info) o)))
      (if local ((push-local-de-ref info) local)
          ((push-global-de-ref info) o)))))

(define (push-ident-de-de-ref info)
  (lambda (o)
    (let ((local (assoc-ref (.locals info) o)))
      (if local ((push-local-de-de-ref info) local)
          (error "TODO: global push-local-de-de-ref")))))

(define (expr->arg info)
  (lambda (o)
    (let ((info ((expr->accu info) o)))
      (append-text info (wrap-as (i386:push-accu))))))

(define (globals:add-string globals)
  (lambda (o)
    (let ((string `(#:string ,o)))
      (if (assoc-ref globals string) globals
          (append globals (list (string->global-entry o)))))))

(define (expr->arg info) ;; FIXME: get Mes curried-definitions
  (lambda (o)
    (let ((text (.text info)))
      (pmatch o

        ((p-expr (string ,string))
         (let* ((globals ((globals:add-string (.globals info)) string))
                (info (clone info #:globals globals)))
           (append-text info ((push-global-address info) `(#:string ,string)))))

        ((p-expr (ident ,name))
         (append-text info ((push-ident info) name)))

        ((cast (type-name (decl-spec-list (type-spec (fixed-type _)))
                          (abs-declr (pointer)))
               ,cast)
         ((expr->arg info) cast))

        ((cast (type-name (decl-spec-list (type-spec (fixed-type ,type)))) ,cast)
         ((expr->arg info) cast))

        ((de-ref (p-expr (ident ,name)))
         (append-text info ((push-ident-de-ref info) name)))

        ((de-ref (de-ref (p-expr (ident ,name))))
         (append-text info ((push-ident-de-de-ref info) name)))

        ((ref-to (p-expr (ident ,name)))
         (append-text info ((push-ident-address info) name)))

        (_ (append-text ((expr->accu info) o)
                        (wrap-as (i386:push-accu))))))))

(define (ident->accu info)
  (lambda (o)
    (let ((local (assoc-ref (.locals info) o))
          (global (assoc-ref (.globals info) o))
          (constant (assoc-ref (.constants info) o)))
      (if local
          (let* ((ptr (local:pointer local))
                 (type (ident->type info o))
                 (size (if (= ptr 0) (ast-type->size info type)
                           4)))
            (cond ((< ptr 0) (wrap-as (i386:local-ptr->accu (local:id local))))
                  (else (wrap-as (case size
                                   ((1) (i386:byte-local->accu (local:id local)))
                                   ((2) (i386:word-local->accu (local:id local)))
                                   (else (i386:local->accu (local:id local))))))))
          (if global
              (let* ((ptr (ident->pointer info o)))
                (cond ((< ptr 0) (list (i386:label->accu `(#:address ,o))))
                      (else (list (i386:label-mem->accu `(#:address ,o))))))
              (if constant (wrap-as (i386:value->accu constant))
                  (list (i386:label->accu `(#:address ,o)))))))))

(define (ident-address->accu info)
  (lambda (o)
    (let ((local (assoc-ref (.locals info) o))
          (global (assoc-ref (.globals info) o))
          (constant (assoc-ref (.constants info) o)))
      (if local (wrap-as (i386:local-ptr->accu (local:id local)))
          (if global (list (i386:label->accu `(#:address ,o)))
              (list (i386:label->accu `(#:address ,o))))))))

(define (ident-address->base info)
  (lambda (o)
    (let ((local (assoc-ref (.locals info) o))
          (global (assoc-ref (.globals info) o))
          (constant (assoc-ref (.constants info) o)))
      (if local (wrap-as (i386:local-ptr->base (local:id local)))
          (if global (list (i386:label->base `(#:address ,o)))
              (list (i386:label->base `(#:address ,o))))))))

(define (value->accu v)
  (wrap-as (i386:value->accu v)))

(define (accu->ident info)
  (lambda (o)
    (let* ((local (assoc-ref (.locals info) o))
           (ptr (ident->pointer info o))
           (size (if (or (= ptr -1) (= ptr 0)) (ident->type-size info o)
                     4)))
      (if local (if (<= size 4) (wrap-as (i386:accu->local (local:id local)))
                    (wrap-as (i386:accu*n->local (local:id local) size)))
          (if (<= size 4) (wrap-as (i386:accu->label o))
              (wrap-as (i386:accu*n->label o size)))))))

(define (value->ident info)
  (lambda (o value)
    (let ((local (assoc-ref (.locals info) o)))
      (if local (wrap-as (i386:value->local (local:id local) value))
          (list (i386:value->label `(#:address ,o) value))))))

(define (ident-add info)
  (lambda (o n)
    (let ((local (assoc-ref (.locals info) o)))
      (if local (wrap-as (i386:local-add (local:id local) n))
          (list (i386:label-mem-add `(#:address ,o) n))))))

(define (expr-add info)
  (lambda (o n)
    (let* ((info ((expr->accu* info) o))
           (info (append-text info (wrap-as (i386:accu-mem-add n)))))
      info)))

(define (ident-address-add info)
  (lambda (o n)
    (let ((local (assoc-ref (.locals info) o)))
      (if local (wrap-as (append (i386:push-accu)
                                 (i386:local->accu (local:id local))
                                 (i386:accu-mem-add n)
                                 (i386:pop-accu)))
          (list (wrap-as (append (i386:push-accu)
                                 (i386:label->accu `(#:address ,o))
                                 (i386:accu-mem-add n)
                                 (i386:pop-accu))))))))

(define (binop->accu info)
  (lambda (a b c)
    (let* ((info ((expr->accu info) a))
           (info ((expr->base info) b)))
      (append-text info (wrap-as c)))))

(define (wrap-as o . annotation)
  `(,@annotation ,o))

(define (make-comment o)
  (wrap-as `((#:comment ,o))))

(define (ast->comment o)
  (let ((source (with-output-to-string (lambda () (pretty-print-c99 o)))))
    (make-comment (string-join (string-split source #\newline) " "))))

(define (accu*n info n)
  (append-text info (wrap-as (case n
                               ((1) (i386:accu->base))
                               ((2) (i386:accu+accu))
                               ((3) (append (i386:accu->base)
                                            (i386:accu+accu)
                                            (i386:accu+base)))
                               ((4) (i386:accu-shl 2))
                               ((8) (append (i386:accu+accu)
                                            (i386:accu-shl 2)))
                               ((12) (append (i386:accu->base)
                                             (i386:accu+accu)
                                             (i386:accu+base)
                                             (i386:accu-shl 2)))
                               ((16) (i386:accu-shl 4))
                               (else (append (i386:value->base n)
                                             (i386:accu*base)))))))

(define (accu->base-mem*n- info n)
  (wrap-as
   (case n
     ((1) (i386:byte-accu->base-mem))
     ((2) (i386:word-accu->base-mem))
     ((4) (i386:accu->base-mem))
     (else (append (let loop ((i 0))
                     (if (>= i n) '()
                         (append (if (= i 0) '()
                                     (append (i386:accu+value 4)
                                             (i386:base+value 4)))
                                 (case (- n i)
                                   ((1) (append (i386:accu+value -3)
                                                (i386:base+value -3)
                                                (i386:accu-mem->base-mem)))
                                   ((2) (append (i386:accu+value -2)
                                                (i386:base+value -2)
                                                (i386:accu-mem->base-mem)))
                                   ((3) (append (i386:accu+value -1)
                                                (i386:base+value -1)
                                                (i386:accu-mem->base-mem)))
                                   (else (i386:accu-mem->base-mem)))
                                 (loop (+ i 4))))))))))

(define (accu->base-mem*n info n)
  (append-text info (accu->base-mem*n- info n)))

(define (accu->local+n info local)
  (lambda (n)
    (let* ((type (local:type local))
           (ptr (local:pointer local))
           (size (if (= ptr -2) (ast-type->size info type)
                     4))
           (id (local:id local)))
      (append-text info (wrap-as (case size
                                   ((1) (i386:byte-accu->local+n id n))
                                   ((2) (i386:word-accu->local+n id n))
                                   (else (i386:accu->local+n id n))))))))

(define (expr->accu* info)
  (lambda (o)
    (pmatch o

      ((p-expr (ident ,name))
       (append-text info ((ident-address->accu info) name)))

      ((de-ref ,expr)
       ((expr->accu info) expr))

      ((d-sel (ident ,field) ,struct)
       (let* ((type (expr->type info struct))
              (offset (field-offset info type field))
              (info ((expr->accu* info) struct)))
         (append-text info (wrap-as (i386:accu+value offset)))))

      ((i-sel (ident ,field) ,struct)
       (let* ((type (expr->type info struct))
              (offset (field-offset info type field))
              (info ((expr->accu* info) struct)))
         (append-text info (append (wrap-as (i386:mem->accu))
                                   (wrap-as (i386:accu+value offset))))))

      ((array-ref ,index ,array)
       (let* ((info ((expr->accu info) index))
              (ptr (expr->pointer info array))
              (size (if (or (= ptr 1) (= ptr -1) (= ptr -2)) (expr->type-size info array)
                        4))
              (info (accu*n info size))
              (info ((expr->base info) array)))
         (append-text info (wrap-as (i386:accu+base)))))

      (_ (error "expr->accu*: unsupported: " o)))))

(define (expr->accu info)
  (lambda (o)
    (let ((locals (.locals info))
          (constants (.constants info))
          (text (.text info))
          (globals (.globals info)))
      (define (add-local locals name type pointer)
        (let* ((id (if (or (null? locals) (not (local-var? (cdar locals)))) 1
                       (1+ (local:id (cdar locals)))))
               (locals (cons (make-local-entry name type pointer id) locals)))
          locals))
      (pmatch o
        ((expr) info)

        ((comma-expr) info)

        ((comma-expr ,a . ,rest)
         (let ((info ((expr->accu info) a)))
           ((expr->accu info) `(comma-expr ,@rest))))

        ((p-expr (string ,string))
         (let* ((globals ((globals:add-string globals) string))
                (info (clone info #:globals globals)))
           (append-text info (list (i386:label->accu `(#:string ,string))))))

        ;; FIXME: FROM INFO ...only zero?!
        ((p-expr (fixed ,value))
         (let ((value (cstring->number value)))
           (append-text info (wrap-as (i386:value->accu value)))))

        ((p-expr (char ,char))
         (let ((char (char->integer (car (string->list char)))))
           (append-text info (wrap-as (i386:value->accu char)))))

        ((p-expr (string . ,strings))
         (append-text info (list (i386:label->accu `(#:string ,(apply string-append strings))))))

        ((p-expr (ident ,name))
         (append-text info ((ident->accu info) name)))

        ((initzer ,initzer)
         ((expr->accu info) initzer))

        ;; offsetoff
        ((ref-to (i-sel (ident ,field) (cast (type-name (decl-spec-list ,struct) (abs-declr (pointer))) (p-expr (fixed ,base)))))
         (let* ((type (decl->ast-type struct))
                (offset (field-offset info type field))
                (base (cstring->number base)))
           (append-text info (wrap-as (i386:value->accu (+ base offset))))))

        ;; &foo
        ((ref-to (p-expr (ident ,name)))
         (append-text info ((ident-address->accu info) name)))

        ;; &*foo
        ((ref-to (de-ref ,expr))
         ((expr->accu info) expr))

        ((ref-to ,expr)
         ((expr->accu* info) expr))

        ((sizeof-expr (p-expr (ident ,name)))
         (let* ((type (ident->type info name))
                (size (ast-type->size info type)))
           (append-text info (wrap-as (i386:value->accu size)))))

        ((sizeof-expr (p-expr (string ,string)))
         (append-text info (wrap-as (i386:value->accu (1+ (string-length string))))))

        ((sizeof-expr (i-sel (ident ,field) (p-expr (ident ,struct))))
         (let* ((type (ident->type info struct))
                (size (field-size info type field)))
           (append-text info (wrap-as (i386:value->accu size)))))

        ((sizeof-expr (d-sel (ident ,field) (p-expr (ident ,struct))))
         (let* ((type (ident->type info struct))
                (size (field-size info type field)))
           (append-text info (wrap-as (i386:value->accu size)))))

        ((sizeof-type (type-name (decl-spec-list (type-spec (fixed-type ,name)))))
         (let* ((type name)
                (size (ast-type->size info type)))
           (append-text info (wrap-as (i386:value->accu size)))))

        ((sizeof-type (type-name (decl-spec-list (type-spec (struct-ref (ident ,type))))))
         (let* ((type `("tag" ,type))
                (size (ast-type->size info type)))
           (append-text info (wrap-as (i386:value->accu size)))))

        ((sizeof-type (type-name (decl-spec-list (type-spec (typename ,type)))))
         (let ((size (ast-type->size info type)))
           (append-text info (wrap-as (i386:value->accu size)))))

        ((sizeof-type (type-name (decl-spec-list ,type) (abs-declr (pointer))))
         (let ((size 4))
           (append-text info (wrap-as (i386:value->accu size)))))

        ;; <expr>[baz]
        ((array-ref ,index ,array)
         (let* ((info ((expr->accu* info) o))
                (ptr (expr->pointer info array))
                (size (if (or (= ptr 1) (= ptr -1) (= ptr -2)) (expr->type-size info array)
                          4)))
           (append-text info (wrap-as (case size
                                        ((1) (i386:byte-mem->accu))
                                        ((2) (i386:word-mem->accu))
                                        ((4) (i386:mem->accu))
                                        (else '()))))))

        ((d-sel ,field ,struct)
         (let* ((info ((expr->accu* info) o))
                (info (append-text info (ast->comment o)))
                (ptr (expr->pointer info o))
                (size (if (= ptr 0) (expr->type-size info o)
                          4)))
           (if (or (= -2 ptr) (= -1 ptr)) info
               (append-text info (wrap-as (case size
                                            ((1) (i386:byte-mem->accu))
                                            ((2) (i386:word-mem->accu))
                                            ((4) (i386:mem->accu))
                                            (else '())))))))

        ((i-sel ,field ,struct)
         (let* ((info ((expr->accu* info) o))
                (info (append-text info (ast->comment o)))
                (ptr (expr->pointer info o))
                (size (if (= ptr 0) (expr->type-size info o)
                          4)))
           (if (or (= -2 ptr) (= ptr -1)) info
               (append-text info (wrap-as (case size
                                            ((1) (i386:byte-mem->accu))
                                            ((2) (i386:word-mem->accu))
                                            ((4) (i386:mem->accu))
                                            (else '())))))))

        ((de-ref ,expr)
         (let* ((info ((expr->accu info) expr))
                (ptr (expr->pointer info expr))
                (size (expr->size info o)))
           (append-text info (wrap-as (case size
                                        ((1) (i386:byte-mem->accu))
                                        ((2) (i386:word-mem->accu))
                                        ((4) (i386:mem->accu))
                                        (else '()))))))

        ((fctn-call (p-expr (ident ,name)) (expr-list . ,expr-list))
         (if (equal? name "asm") (let ((arg0 (cadr (cadar expr-list)))) ;; FIXME
                                   (append-text info (wrap-as (asm->m1 arg0))))
             (let* ((text-length (length text))
                    (args-info (let loop ((expressions (reverse expr-list)) (info info))
                                 (if (null? expressions) info
                                     (loop (cdr expressions) ((expr->arg info) (car expressions))))))
                    (n (length expr-list)))
               (if (not (assoc-ref locals name))
                   (begin
                     (if (and (not (assoc name (.functions info)))
                              (not (assoc name globals))
                              (not (equal? name (.function info))))
                         (stderr "warning: undeclared function: ~a\n" name))
                     (append-text args-info (list (i386:call-label name n))))
                   (let* ((empty (clone info #:text '()))
                          (accu ((expr->accu empty) `(p-expr (ident ,name)))))
                     (append-text args-info (append (.text accu)
                                                    (list (i386:call-accu n)))))))))

        ((fctn-call ,function (expr-list . ,expr-list))
         (let* ((text-length (length text))
                (args-info (let loop ((expressions (reverse expr-list)) (info info))
                             (if (null? expressions) info
                                 (loop (cdr expressions) ((expr->arg info) (car expressions))))))
                (n (length expr-list))
                (empty (clone info #:text '()))
                (accu ((expr->accu empty) function)))
           (append-text args-info (append (.text accu)
                                          (list (i386:call-accu n))))))

        ((cond-expr . ,cond-expr)
         ((ast->info info) `(expr-stmt ,o)))

        ((post-inc ,expr)
         (let* ((info (append ((expr->accu info) expr)))
                (info (append-text info (wrap-as (i386:push-accu))))
                (ptr (expr->pointer info expr))
                (size (cond ((= ptr 1) (expr->type-size info expr))
                            ((> ptr 1) 4)
                            (else 1)))
                (info ((expr-add info) expr size))
                (info (append-text info (wrap-as (i386:pop-accu)))))
           info))

        ((post-dec ,expr)
         (let* ((info (append ((expr->accu info) expr)))
                (info (append-text info (wrap-as (i386:push-accu))))
                (ptr (expr->pointer info expr))
                (size (cond ((= ptr 1) (expr->type-size info expr))
                            ((> ptr 1) 4)
                            (else 1)))
                (info ((expr-add info) expr (- size)))
                (info (append-text info (wrap-as (i386:pop-accu)))))
           info))

        ((pre-inc ,expr)
         (let* ((ptr (expr->pointer info expr))
                (size (cond ((= ptr 1) (expr->type-size info expr))
                            ((> ptr 1) 4)
                            (else 1)))
                (info ((expr-add info) expr size))
                (info (append ((expr->accu info) expr))))
           info))

        ((pre-dec ,expr)
         (let* ((ptr (expr->pointer info expr))
                (size (cond ((= ptr 1) (expr->type-size info expr))
                            ((> ptr 1) 4)
                            (else 1)))
                (info ((expr-add info) expr (- size)))
                (info (append ((expr->accu info) expr))))
           info))



        ((add ,a (p-expr (fixed ,value)))
         ;;(stderr "add ~s\n"(with-output-to-string (lambda () (pretty-print-c99 o))))
         (let* ((ptr (pke "ptr" (expr->pointer info a)))
                (type0 (expr->type info a))
                (struct? (pke "struct" (memq (type:type (ast-type->type info type0)) '(struct union))))
                (size (cond ((= ptr 1) (expr->type-size info a))
                            ((> ptr 1) 4)
                            ((and struct? (= ptr -2)) 4)
                            ((and struct? (= ptr 2)) 4)
                            (else 1)))
                (info ((expr->accu info) a))
                (value (cstring->number value))
                (value (pke "VALUE" (* size value))))
           (pke "size" size)
           (append-text info (wrap-as (i386:accu+value value)))))

        ((add ,a ,b)
         (let* ((ptr (expr->pointer info a))
                (ptr-b (expr->pointer info b))
                (type0 (expr->type info a))
                (struct? (memq (type:type (ast-type->type info type0)) '(struct union)))
                (size (cond ((= ptr 1) (expr->type-size info a))
                            ((> ptr 1) 4)
                            ((and struct? (= ptr -2)) 4)
                            ((and struct? (= ptr 2)) 4)
                            (else 1))))
           (if (or (= size 1)) ((binop->accu info) a b (i386:accu+base))
               (let* ((info ((expr->accu info) b))
                      (info (append-text info (wrap-as (append (i386:value->base size)
                                                               (i386:accu*base)
                                                               (i386:accu->base)))))
                      (info ((expr->accu info) a)))
                 (append-text info (wrap-as (i386:accu+base)))))))

        ((sub ,a (p-expr (fixed ,value)))
         (let* ((ptr (expr->pointer info a))
                (type0 (expr->type info a))
                (struct? (memq (type:type (ast-type->type info type0)) '(struct union)))
                (size (cond ((= ptr 1) (expr->type-size info a))
                            ((> ptr 1) 4)
                            ((and struct? (= ptr -2)) 4)
                            ((and struct? (= ptr 2)) 4)
                            (else 1)))
                (info ((expr->accu info) a))
                (value (cstring->number value))
                (value (* size value)))
           (append-text info (wrap-as (i386:accu+value (- value))))))

        ((sub ,a ,b)
         ;;(stderr "sub ~s\n"(with-output-to-string (lambda () (pretty-print-c99 o))))
         (let* ((ptr (pke "ptr" (expr->pointer info a)))
                (ptr-b (pke "ptr-b" (expr->pointer info b)))
                (type0 (expr->type info a))
                (struct? (pke "struct?" (memq (type:type (ast-type->type info type0)) '(struct union))))
                (size  (cond ((= ptr 1) (expr->type-size info a))
                             ((> ptr 1) 4)
                             ((and struct? (= ptr -2)) 4)
                             ((and struct? (= ptr 2)) 4)
                             (else 1))))
           (pke "size" size)
           (if (or (= size 1) (or (= ptr-b -2) (= ptr-b 1)))
               (let ((info ((binop->accu info) a b (i386:accu-base))))
                 (if (and (not (= ptr-b -2)) (not (= ptr-b 1))) info
                     (append-text info (wrap-as (append (i386:value->base size)
                                                        (i386:accu/base))))))
               (let* ((info ((expr->accu info) b))
                      (info (append-text info (wrap-as (append (i386:value->base size)
                                                               (i386:accu*base)
                                                               (i386:accu->base)))))
                      (info ((expr->accu info) a)))
                 (append-text info (wrap-as (i386:accu-base)))))))

        ((bitwise-and ,a ,b) ((binop->accu info) a b (i386:accu-and-base)))
        ((bitwise-not ,expr)
         (let ((info ((ast->info info) expr)))
           (append-text info (wrap-as (i386:accu-not)))))
        ((bitwise-or ,a ,b) ((binop->accu info) a b (i386:accu-or-base)))
        ((bitwise-xor ,a ,b) ((binop->accu info) a b (i386:accu-xor-base)))
        ((lshift ,a ,b) ((binop->accu info) a b (i386:accu<<base)))
        ((rshift ,a ,b) ((binop->accu info) a b (i386:accu>>base)))
        ((div ,a ,b) ((binop->accu info) a b (i386:accu/base)))
        ((mod ,a ,b) ((binop->accu info) a b (i386:accu%base)))
        ((mul ,a ,b) ((binop->accu info) a b (i386:accu*base)))

        ((not ,expr)
         (let* ((test-info ((ast->info info) expr)))
           (clone info #:text
                  (append (.text test-info)
                          (wrap-as (i386:accu-negate)))
                  #:globals (.globals test-info))))

        ((neg ,expr)
         (let ((info ((expr->base info) expr)))
           (append-text info (append (wrap-as (i386:value->accu 0))
                                     (wrap-as (i386:sub-base))))))

        ((eq ,a ,b) ((binop->accu info) a b (append (i386:sub-base) (i386:z->accu))))
        ((ge ,a ,b) ((binop->accu info) a b (append (i386:sub-base) (i386:ge?->accu))))
        ((gt ,a ,b) ((binop->accu info) a b (append (i386:sub-base) (i386:g?->accu) (i386:accu-test))))

        ;; FIXME: set accu *and* flags
        ((ne ,a ,b) ((binop->accu info) a b (append (i386:push-accu)
                                                    (i386:sub-base)
                                                    (i386:nz->accu)
                                                    (i386:accu<->stack)
                                                    (i386:sub-base)
                                                    (i386:xor-zf)
                                                    (i386:pop-accu))))

        ((ne ,a ,b) ((binop->accu info) a b (append (i386:sub-base) (i386:xor-zf))))
        ((le ,a ,b) ((binop->accu info) a b (append (i386:sub-base) (i386:le?->accu))))
        ((lt ,a ,b) ((binop->accu info) a b (append (i386:sub-base) (i386:l?->accu))))

        ((or ,a ,b)
         (let* ((info ((expr->accu info) a))
                (here (number->string (length (.text info))))
                (skip-b-label (string-append "_" (.function info) "_" here "_or_skip_b"))
                (info (append-text info (wrap-as (i386:accu-test))))
                (info (append-text info (wrap-as (i386:jump-nz skip-b-label))))
                (info (append-text info (wrap-as (i386:accu-test))))
                (info ((expr->accu info) b))
                (info (append-text info (wrap-as (i386:accu-test))))
                (info (append-text info (wrap-as `((#:label ,skip-b-label))))))
           info))

        ((and ,a ,b)
         (let* ((info ((expr->accu info) a))
                (here (number->string (length (.text info))))
                (skip-b-label (string-append "_" (.function info) "_" here "_and_skip_b"))
                (info (append-text info (wrap-as (i386:accu-test))))
                (info (append-text info (wrap-as (i386:jump-z skip-b-label))))
                (info (append-text info (wrap-as (i386:accu-test))))
                (info ((expr->accu info) b))
                (info (append-text info (wrap-as (i386:accu-test))))
                (info (append-text info (wrap-as `((#:label ,skip-b-label))))))
           info))

        ((cast ,type ,expr)
         ((expr->accu info) expr))

        ((assn-expr (de-ref (post-inc (p-expr (ident ,name)))) (op ,op) ,b)
         (let* ((info ((expr->accu info) `(assn-expr (de-ref (p-expr (ident ,name))) (op ,op) ,b)))
                (type (ident->type info name))
                (ptr (ident->pointer info name))
                (size (if (> ptr 1) 4 1)))
           (append-text info ((ident-add info) name size))))

        ((assn-expr (de-ref (post-dec (p-expr (ident ,name)))) (op ,op) ,b)
         (let* ((info ((expr->accu info) `(assn-expr (de-ref (p-expr (ident ,name))) (op ,op) ,b)))
                (type (ident->type info name))
                (ptr (ident->pointer info name))
                (size (if (> ptr 1) 4 1)))
           (append-text info ((ident-add info) name (- size)))))

        ((assn-expr ,a (op ,op) ,b)
         (let* ((info (append-text info (ast->comment o)))
                (ptr-a (expr->pointer info a))
                (ptr-b (expr->pointer info b))
                (size-a (expr->size info a))
                (size-b (expr->size info b))
                (info ((expr->accu info) b))
                (info (if (equal? op "=") info
                          (let* ((ptr (expr->pointer info a))
                                 (ptr-b (expr->pointer info b))
                                 (type0 (expr->type info a))
                                 (struct? (memq (type:type (ast-type->type info type0)) '(struct union)))
                                 (size (cond ((= ptr 1) (expr->type-size info a))
                                             ((> ptr 1) 4)
                                             ((and struct? (= ptr -2)) 4)
                                             ((and struct? (= ptr 2)) 4)
                                             (else 1)))
                                 (info (if (or (= size 1) (= ptr-b 1)) info
                                           (let ((info (append-text info (wrap-as (i386:value->base size)))))
                                             (append-text info (wrap-as (i386:accu*base))))))
                                 (info (append-text info (wrap-as (i386:push-accu))))
                                 (info ((expr->accu info) a))
                                 (info (append-text info (wrap-as (i386:pop-base))))
                                 (info (append-text info (cond ((equal? op "+=") (wrap-as (i386:accu+base)))
                                                               ((equal? op "-=") (wrap-as (i386:accu-base)))
                                                               ((equal? op "*=") (wrap-as (i386:accu*base)))
                                                               ((equal? op "/=") (wrap-as (i386:accu/base)))
                                                               ((equal? op "%=") (wrap-as (i386:accu%base)))
                                                               ((equal? op "&=") (wrap-as (i386:accu-and-base)))
                                                               ((equal? op "|=") (wrap-as (i386:accu-or-base)))
                                                               ((equal? op "^=") (wrap-as (i386:accu-xor-base)))
                                                               ((equal? op ">>=") (wrap-as (i386:accu>>base)))
                                                               ((equal? op "<<=") (wrap-as (i386:accu<<base)))
                                                               (else (error (format #f "mescc: op ~a not supported: ~a\n" op o)))))))
                            (cond ((not (and (= ptr 1) (= ptr-b 1))) info)
                                  ((equal? op "-=") (append-text info (wrap-as (append (i386:value->base size)
                                                                                       (i386:accu/base)))))
                                  (else (error (format #f "invalid operands to binary ~s (have ~s* and ~s*)" op type0 (expr->type info b)))))))))
           (when (and (equal? op "=")
                      (not (= size-a size-b))
                      (not (and (or (= size-a 1) (= size-a 2))
                                (= size-b 4)))
                      (not (and (= size-a 2)
                                (= size-b 4)))
                      (not (and (= size-a 4)
                                (or (= size-b 1) (= size-b 2)))))
             (stderr "ERROR assign: ~a" (with-output-to-string (lambda () (pretty-print-c99 o))))
             (stderr "   size[~a]:~a != size[~a]:~a\n"  ptr-a size-a ptr-b size-b))
           (pmatch a
             ((p-expr (ident ,name))
              (if (or (<= size-a 4) ;; FIXME: long long = int
                      (<= size-b 4)) (append-text info ((accu->ident info) name))
                      (let ((info ((expr->base* info) a)))
                        (accu->base-mem*n info size-a))))
             (_ (let ((info ((expr->base* info) a)))
                  (accu->base-mem*n info (min size-a (max 4 size-b)))))))) ;; FIXME: long long = int

        (_ (error "expr->accu: unsupported: " o))))))

(define (expr->base info)
  (lambda (o)
    (let* ((info (append-text info (wrap-as (i386:push-accu))))
           (info ((expr->accu info) o))
           (info (append-text info (wrap-as (append (i386:accu->base) (i386:pop-accu))))))
      info)))

(define (expr->base* info)
  (lambda (o)
    (let* ((info (append-text info (wrap-as (i386:push-accu))))
           (info ((expr->accu* info) o))
           (info (append-text info (wrap-as (i386:accu->base))))
           (info (append-text info (wrap-as (i386:pop-accu)))))
      info)))

(define (clause->info info i label last?)
  (define clause-label
    (string-append label "clause" (number->string i)))
  (define body-label
    (string-append label "body" (number->string i)))
  (define (jump label)
    (wrap-as (i386:jump label)))
  (define (jump-nz label)
    (wrap-as (i386:jump-nz label)))
  (define (jump-z label)
    (wrap-as (i386:jump-z label)))
  (define (test->text test)
    (let ((value (pmatch test
                   (0 0)
                   ((p-expr (char ,value)) (char->integer (car (string->list value))))
                   ((p-expr (ident ,constant)) (assoc-ref (.constants info) constant))
                   ((p-expr (fixed ,value)) (cstring->number value))
                   ((neg (p-expr (fixed ,value))) (- (cstring->number value)))
                   (_ (error "case test: unsupported: " test)))))
      (append (wrap-as (i386:accu-cmp-value value))
              (jump-z body-label))))
  (define (cases+jump info cases)
    (let* ((info (append-text info (wrap-as `((#:label ,clause-label)))))
           (next-clause-label (if last? (string-append label "break")
                                  (string-append label "clause" (number->string (1+ i)))))
           (info (append-text info (apply append cases)))
           (info (if (null? cases) info
                     (append-text info (jump next-clause-label))))
           (info (append-text info (wrap-as `((#:label ,body-label))))))
      info))

  (lambda (o)
    (let loop ((o o) (cases '()) (clause #f))
      (pmatch o
        ((case ,test ,statement)
         (loop statement (append cases (list (test->text test))) clause))
        ((default ,statement)
         (loop statement cases clause))
        ((default . ,statements)
         (loop `(compd-stmt (block-item-list ,@statements)) cases clause))
        ((compd-stmt (block-item-list))
         (loop '() cases clause))
        ((compd-stmt (block-item-list . ,elements))
         (let ((clause (or clause (cases+jump info cases))))
           (loop `(compd-stmt (block-item-list ,@(cdr elements))) cases
                 ((ast->info clause) (car elements)))))
        (()
         (let ((clause (or clause (cases+jump info cases))))
           (if last? clause
               (let ((next-body-label (string-append label "body"
                                                     (number->string (1+ i)))))
                 (append-text clause (wrap-as (i386:jump next-body-label)))))))
        (_
         (let ((clause (or clause (cases+jump info cases))))
           (loop '() cases
                 ((ast->info clause) o))))))))

(define (test-jump-label->info info label)
  (define (jump type . test)
    (lambda (o)
      (let* ((info ((ast->info info) o))
             (info (append-text info (make-comment "jmp test LABEL")))
             (jump-text (wrap-as (type label))))
        (append-text info (append (if (null? test) '() (car test))
                                  jump-text)))))
  (lambda (o)
    (pmatch o
      ((expr) info)
      ;; unsigned
      ;; ((le ,a ,b) ((jump i386:jump-ncz) o)) ; ja
      ;; ((lt ,a ,b) ((jump i386:jump-nc) o))  ; jae
      ;; ((ge ,a ,b) ((jump i386:jump-ncz) o))
      ;; ((gt ,a ,b) ((jump i386:jump-nc) o))

      ((le ,a ,b) ((jump i386:jump-g) o))
      ((lt ,a ,b) ((jump i386:jump-ge) o))
      ((ge ,a ,b) ((jump i386:jump-l) o))
      ((gt ,a ,b) ((jump i386:jump-le) o))

      ((ne ,a ,b) ((jump i386:jump-nz) o))
      ((eq ,a ,b) ((jump i386:jump-nz) o))
      ((not _) ((jump i386:jump-z) o))

      ((and ,a ,b)
       (let* ((info ((test-jump-label->info info label) a))
              (info ((test-jump-label->info info label) b)))
         info))

      ((or ,a ,b)
       (let* ((here (number->string (length (.text info))))
              (skip-b-label (string-append label "_skip_b_" here))
              (b-label (string-append label "_b_" here))
              (info ((test-jump-label->info info b-label) a))
              (info (append-text info (wrap-as (i386:jump skip-b-label))))
              (info (append-text info (wrap-as `((#:label ,b-label)))))
              (info ((test-jump-label->info info label) b))
              (info (append-text info (wrap-as `((#:label ,skip-b-label))))))
         info))

      ((array-ref ,index ,expr) (let* ((ptr (expr->pointer info expr))
                                       (size (if (= ptr 1) (ast-type->size info expr)
                                                 4)))
                                  ((jump (if (= size 1) i386:jump-byte-z
                                             i386:jump-z)
                                         (wrap-as (i386:accu-zero?))) o)))

      ((de-ref ,expr) (let* ((ptr (expr->pointer info expr))
                             (size (if (= ptr 1) (ast-type->size info expr)
                                       4)))
                        ((jump (if (= size 1) i386:jump-byte-z
                                   i386:jump-z)
                               (wrap-as (i386:accu-zero?))) o)))

      ((assn-expr (p-expr (ident ,name)) ,op ,expr)
       ((jump i386:jump-z
              (append ((ident->accu info) name)
                      (wrap-as (i386:accu-zero?)))) o))

      (_ ((jump i386:jump-z (wrap-as (i386:accu-zero?))) o)))))

(define (cstring->number s)
  (let ((s (cond ((string-suffix? "ULL" s) (string-drop-right s 3))
                 ((string-suffix? "UL" s) (string-drop-right s 2))
                 ((string-suffix? "LL" s) (string-drop-right s 2))
                 ((string-suffix? "L" s) (string-drop-right s 1))
                 (else s))))
    (cond ((string-prefix? "0x" s) (string->number (string-drop s 2) 16))
          ((string-prefix? "0b" s) (string->number (string-drop s 2) 2))
          ((string-prefix? "0" s) (string->number s 8))
          (else (string->number s)))))

(define (expr->number info o)
  (pmatch o
    ((p-expr (fixed ,a))
     (cstring->number a))
    ((neg ,a)
     (- (expr->number info a)))
    ((add ,a ,b)
     (+ (expr->number info a) (expr->number info b)))
    ((bitwise-and ,a ,b)
     (logand (expr->number info a) (expr->number info b)))
    ((bitwise-not ,a)
     (lognot (expr->number info a)))
    ((bitwise-or ,a ,b)
     (logior (expr->number info a) (expr->number info b)))
    ((div ,a ,b)
     (quotient (expr->number info a) (expr->number info b)))
    ((mul ,a ,b)
     (* (expr->number info a) (expr->number info b)))
    ((sub ,a ,b)
     (- (expr->number info a) (expr->number info b)))
    ((sizeof-type (type-name (decl-spec-list (type-spec ,type))))
     (ast-type->size info type))
    ((sizeof-expr (d-sel (ident ,field) (p-expr (ident ,struct))))
     (let ((type (ident->type info struct)))
       (field-size info type field)))
    ((sizeof-expr (i-sel (ident ,field) (p-expr (ident ,struct))))
     (let ((type (ident->type info struct)))
       (field-size info type field)))
    ((lshift ,x ,y)
     (ash (expr->number info x) (expr->number info y)))
    ((rshift ,x ,y)
     (ash (expr->number info x) (- (expr->number info y))))
    ((p-expr (ident ,name))
     (let ((value (assoc-ref (.constants info) name)))
       (or value
           (error (format #f "expr->number: undeclared identifier: ~s\n" o)))))
    ((cast ,type ,expr) (expr->number info expr))
    ((cond-expr ,test ,then ,else)
     (if (p-expr->bool info test) (expr->number info then) (expr->number info else)))
    (_  (error (format #f "expr->number: not supported: ~s\n" o)))))

(define (p-expr->bool info o)
  (pmatch o
    ((eq ,a ,b) (eq? (expr->number info a) (expr->number info b)))))

(define (struct-field info)
  (lambda (o)
    (pmatch o
      ((comp-decl (decl-spec-list (type-spec (enum-ref (ident ,type))))
                  (comp-declr-list (comp-declr (ident ,name))))
       (list name `("tag" ,type) 4 0))
      ((comp-decl (decl-spec-list (type-spec (fixed-type ,type))) (comp-declr-list (comp-declr (ident ,name))))
       (list name type (ast-type->size info type) 0))
      ((comp-decl (decl-spec-list (type-spec (typename ,type))) (comp-declr-list (comp-declr (ident ,name))))
       (list name type (ast-type->size info type) 0))
      ((comp-decl (decl-spec-list (type-spec (typename ,type))) (comp-declr-list (comp-declr (ptr-declr (pointer (pointer)) (ident ,name)))))
       (list name type 4 2))
      ((comp-decl (decl-spec-list (type-spec (fixed-type ,type))) (comp-declr-list (comp-declr (ftn-declr (scope (ptr-declr (pointer) (ident ,name))) (param-list . ,param-list)))))
       (list name type 4 1))
      ((comp-decl (decl-spec-list (type-spec (fixed-type ,type))) (comp-declr-list (comp-declr (ptr-declr (pointer) (ident ,name)))))
       (list name type 4 1))
      ((comp-decl (decl-spec-list (type-spec (fixed-type ,type))) (comp-declr-list (comp-declr (ptr-declr (pointer (pointer)) (ident ,name)))))
       (list name type 4 2))
      ((comp-decl (decl-spec-list (type-spec (void))) (comp-declr-list (comp-declr (ptr-declr (pointer (pointer)) (ident ,name)))))
       (list name "void" 4 2))
      ((comp-decl (decl-spec-list (type-spec (void))) (comp-declr-list (comp-declr (ptr-declr (pointer) (ident ,name)))))
       (list name "void" 4 1))
      ((comp-decl (decl-spec-list (type-spec (void))) (comp-declr-list (comp-declr (ftn-declr (scope (ptr-declr (pointer) (ident ,name))) (param-list . ,param-list)))))
       (list name "void" 4 1))
      ((comp-decl (decl-spec-list (type-spec (typename ,type))) (comp-declr-list (comp-declr (ptr-declr (pointer) (ident ,name)))))
       (list name type 4 1))

      ;; FIXME: array: -1,-2-3, name??
      ((comp-decl (decl-spec-list (type-spec (typename ,type))) (comp-declr-list (comp-declr (ptr-declr (pointer) (array-of (ident ,name) ,count)))))
       (let ((size 4)
             (count (expr->number info count)))
         (list name type (* count size) -2)))

      ((comp-decl (decl-spec-list (type-spec ,type)) (comp-declr-list (comp-declr (array-of (ident ,name) ,count))))
       (let ((size (ast-type->size info type))
             (count (expr->number info count)))
         (list name type (* count size) -1)))

      ((comp-decl (decl-spec-list (type-spec (struct-ref (ident ,type)))) (comp-declr-list (comp-declr (ptr-declr (pointer (pointer)) (ident ,name)))))
       (list name `("tag" ,type) 4 2))

      ((comp-decl (decl-spec-list (type-spec (struct-ref (ident ,type)))) (comp-declr-list (comp-declr (ptr-declr (pointer) (ident ,name)))))
       (list name `("tag" ,type) 4 1))

      ((comp-decl (decl-spec-list (type-spec (struct-ref (ident ,type)))) (comp-declr-list (comp-declr (ident ,name))))
       (let ((size (ast-type->size info `("tag" ,type))))
         (list name `("tag" ,type) size 0)))

      ((comp-decl (decl-spec-list (type-spec (struct-def (field-list . ,fields)))))
       `(struct ,@(map (struct-field info) fields)))

      ((comp-decl (decl-spec-list (type-spec (union-ref (ident ,type)))) (comp-declr-list (comp-declr (ident ,name))))
       (let ((size (ast-type->size info `("tag" ,type))))
         (list name `("tag" ,type) size 0)))

      ((comp-decl (decl-spec-list (type-spec (union-def (field-list . ,fields)))))
       `(union ,@(map (struct-field info) fields)))

      (_ (error "struct-field: unsupported: " o)))))

(define (local-var? o) ;; formals < 0, locals > 0
  (positive? (local:id o)))

(define (ptr-declr->pointer o)
  (pmatch o
    ((pointer) 1)
    ((pointer (pointer)) 2)
    ((pointer (pointer (pointer))) 3)
    (_ (error "ptr-declr->pointer unsupported: " o))))

(define (init-declr->name o)
  (pmatch o
    ((ident ,name) name)
    ((ptr-declr ,pointer (ident ,name)) name)
    ((array-of (ident ,name)) name)
    ((array-of (ident ,name) ,index) name)
    ((ftn-declr (scope (ptr-declr (pointer) (ident ,name))) (param-list . ,params)) name)
    ((ptr-declr (pointer) (array-of (ident ,name))) name)
    ((ptr-declr (pointer) (array-of (ident ,name) (p-expr ,size))) name)
    (_ (error "init-declr->name unsupported: " o))))

(define (init-declr->count info o)
  (pmatch o
    ((array-of (ident ,name) ,count) (expr->number info count))
    (_ #f)))

(define (init-declr->pointer o)
  (pmatch o
    ((ident ,name) 0)
    ((ptr-declr ,pointer (ident ,name)) (ptr-declr->pointer pointer))
    ((array-of (ident ,name) ,index) -2)
    ((array-of (ident ,name)) -2)
    ((ftn-declr (scope (ptr-declr ,pointer (ident ,name))) (param-list . ,params)) (ptr-declr->pointer pointer))
    ((ptr-declr (pointer) (array-of (ident ,name))) -2)
    ((ptr-declr (pointer) (array-of (ident ,name) (p-expr ,size))) -2)
    (_ (error "init-declr->pointer unsupported: " o))))

(define (statements->clauses statements)
  (let loop ((statements statements) (clauses '()))
    (if (null? statements) clauses
        (let ((s (car statements)))
          (pmatch s
            ((case ,test (compd-stmt (block-item-list . _)))
             (loop (cdr statements) (append clauses (list s))))
            ((case ,test (break))
             (loop (cdr statements) (append clauses (list s))))
            ((case ,test) (loop (cdr statements) (append clauses (list s))))

            ((case ,test ,statement)
             (let loop2 ((statement statement) (heads `((case ,test))))
               (define (heads->case heads statement)
                 (if (null? heads) statement
                     (append (car heads) (list (heads->case (cdr heads) statement)))))
               (pmatch statement
                 ((case ,t2 ,s2) (loop2 s2 (append heads `((case ,t2)))))
                 ((default ,s2) (loop2 s2 (append heads `((default)))))
                 ((compd-stmt (block-item-list . _)) (loop (cdr statements) (append clauses (list (heads->case heads statement)))))
                 (_ (let loop3 ((statements (cdr statements)) (c (list statement)))
                      (if (null? statements) (loop statements (append clauses (list (heads->case heads `(compd-stmt (block-item-list ,@c))))))
                          (let ((s (car statements)))
                            (pmatch s
                              ((case . _) (loop statements (append clauses (list (heads->case heads `(compd-stmt (block-item-list ,@c)))))))
                              ((default _) (loop statements (append clauses (list (heads->case heads `(compd-stmt (block-item-list ,@c)))))))
                              ((break) (loop (cdr statements) (append clauses (list (heads->case heads `(compd-stmt (block-item-list ,@(append c (list s)))))))))
                              (_ (loop3 (cdr statements) (append c (list s))))))))))))
            ((default (compd-stmt (block-item-list _)))
             (loop (cdr statements) (append clauses (list s))))
            ((default . ,statement)
             (let loop2 ((statements (cdr statements)) (c statement))
               (if (null? statements) (loop statements (append clauses (list `(default ,@c))))
                   (let ((s (car statements)))
                     (pmatch s
                       ((compd-stmt (block-item-list . _)) (loop (cdr statements) (append clauses (list `(default ,s)))))
                       ((case . _) (loop statements (append clauses (list `(default (compd-stmt (block-item-list ,@c)))))))
                       ((default _) (loop statements (append clauses (list `(default (compd-stmt (block-item-list ,@c)))))))
                       ((break) (loop (cdr statements) (append clauses (list `(default (compd-stmt (block-item-list ,@(append c (list s)))))))))

                       (_ (loop2 (cdr statements) (append c (list s)))))))))
            (_ (error "statements->clauses: unsupported:" s)))))))

(define (decl->info info)
  (lambda (o)
    (let ((functions (.functions info))
          (globals (.globals info))
          (locals (.locals info))
          (constants (.constants info))
          (types (.types info))
          (text (.text info)))
      (define (add-local locals name type pointer)
        (let* ((id (if (or (null? locals) (not (local-var? (cdar locals)))) 1
                       (1+ (local:id (cdar locals)))))
               (locals (cons (make-local-entry name type pointer id) locals)))
          locals))
      (define (declare name)
        (if (member name functions) info
            (clone info #:functions (cons (cons name #f) functions))))
      (pmatch o

        ;; FIXME: Nyacc sometimes produces extra parens: (ident (<struct-name>))
        ((decl (decl-spec-list (type-spec (typename ,type))) (init-declr-list (init-declr (ftn-declr (ident ,name) (param-list . ,param-list)))))
         (declare name))

        ((decl (decl-spec-list (stor-spec (typedef)) (type-spec (fixed-type ,type))) (init-declr-list (init-declr (ident ,name))))
         (clone info #:types (cons (cons name (get-type types type)) types)))

        ;; int foo ();
        ((decl (decl-spec-list (type-spec (fixed-type ,type))) (init-declr-list (init-declr (ftn-declr (ident ,name) (param-list . ,param-list)))))
         (declare name))

        ;; void foo ();
        ((decl (decl-spec-list (type-spec (void))) (init-declr-list (init-declr (ftn-declr (ident ,name) (param-list . ,param-list)))))
         (declare name))

        ;; void foo (*);
        ((decl (decl-spec-list (type-spec (void))) (init-declr-list (init-declr (ptr-declr (pointer) (ftn-declr (ident ,name) (param-list . ,param-list))))))
         (declare name))

        ;; char *strcpy ();
        ((decl (decl-spec-list (type-spec (fixed-type ,type))) (init-declr-list (init-declr (ptr-declr (pointer) (ftn-declr (ident ,name) (param-list . ,param-list))))))
         (declare name))

        ;; printf (char const* format, ...)
        ((decl (decl-spec-list ,type) (init-declr-list (init-declr (ftn-declr (ident ,name) (param-list ,param-list . (ellipsis))))))
         (declare name))

        ;; <name> tcc_new
        ((decl (decl-spec-list ,type) (init-declr-list (init-declr (ptr-declr (pointer) (ftn-declr (ident ,name) (param-list . ,param-list))))))
         (declare name))

        ;; extern type foo ()
        ((decl (decl-spec-list (stor-spec (extern)) ,type) (init-declr-list (init-declr (ftn-declr (ident ,name) (param-list . ,param-list)))))
         (declare name))

        ;; struct TCCState;
        ((decl (decl-spec-list (type-spec (struct-ref (ident ,name)))))
         info)

        ;; extern type global;
        ((decl (decl-spec-list (stor-spec (extern)) ,type) (init-declr-list (init-declr (ident ,name))))
         info)

        ((decl (decl-spec-list (stor-spec (static)) ,type) (init-declr-list (init-declr (ident ,name))))
         ((decl->info info) `(decl (decl-spec-list ,type) (init-declr-list (init-declr (ident ,name)))))
         info)

        ;; extern foo *bar;
        ((decl (decl-spec-list (stor-spec (extern)) ,type) (init-declr-list (init-declr (ptr-declr ,pointer (ident ,name)))))
         info)

        ((decl (decl-spec-list (stor-spec (static)) ,type) (init-declr-list (init-declr (ptr-declr ,pointer (ident ,name)))))
         ((decl->info info) `(decl (decl-spec-list ,type) (init-declr-list (init-declr (ptr-declr ,pointer (ident ,name)))))))

        ;; ST_DATA int ch, tok; -- TCC, why oh why so difficult?
        ((decl (decl-spec-list (stor-spec (extern)) (type-spec (fixed-type ,type))) (init-declr-list (init-declr (ident ,name)) . ,rest))
         info)

        ;; ST_DATA Section *text_section, *data_section, *bss_section; /* predefined sections */
        ((decl (decl-spec-list (stor-spec (extern)) (type-spec (typename ,type))) (init-declr-list (init-declr (ptr-declr (pointer) (ident ,name))) . ,rest))
         info)

        ;; ST_DATA CType char_pointer_type, func_old_type, int_type, size_type;
        ((decl (decl-spec-list (stor-spec (extern)) (type-spec (typename ,type))) (init-declr-list (init-declr (ident ,name)) . ,rest))
         info)

        ;; ST_DATA SValue __vstack[1+/*to make bcheck happy*/ VSTACK_SIZE], *vtop;
        ;; Yay, let's hear it for the T-for Tiny in TCC!?
        ((decl (decl-spec-list (stor-spec (extern)) (type-spec (typename ,type))) (init-declr-list (init-declr (array-of (ident ,name) (add (p-expr (fixed ,a)) (p-expr (fixed ,b))))) (init-declr (ptr-declr (pointer) (ident ,name2)))))
         info)

        ((decl (decl-spec-list (stor-spec (typedef)) (type-spec (struct-ref (ident ,type)))) (init-declr-list (init-declr (ident ,name))))
         (clone info #:types (cons (cons name (or (get-type types type) `(typedef ("tag" ,type)))) types)))

        ((decl (decl-spec-list (stor-spec (typedef)) (type-spec (struct-ref (ident ,type)))) (init-declr-list (init-declr (ident ,name))))
         (clone info #:types (cons (cons name (or (get-type types type) `(typedef ("tag" ,type)))) types)))

        ((decl (decl-spec-list (stor-spec (typedef)) (type-spec (typename ,type))) (init-declr-list (init-declr (ident ,name))))
         (clone info #:types (cons (cons name (or (get-type types type) `(typedef ,type))) types)))

        ((decl (decl-spec-list (stor-spec (typedef)) (type-spec (typename ,type))) (init-declr-list (init-declr (array-of (ident ,name) ,value))))
         (let* ((type (get-type types type))
                (value (expr->number info value))
                (size (* value 4))
                (pointer -1)
                (type (make-type 'array size pointer type)))
           (clone info #:types (cons (cons name type) types))))

        ((decl (decl-spec-list (stor-spec (typedef)) (type-spec (struct-ref (ident ,type)))) (init-declr-list (init-declr (ptr-declr ,pointer (ident ,name)))))
         (let* ((pointer (expr->pointer info pointer))
                (type (or (get-type types type) `(typedef ,type)))
                (size 4)
                (type (make-type 'typedef size pointer type)))
           (clone info #:types (cons (cons name type) types))))

        ((decl (decl-spec-list (stor-spec (typedef)) (type-spec (struct-def ,field-list))) (init-declr-list (init-declr (ident ,name))))
         ((decl->info info) `(decl (decl-spec-list (stor-spec (typedef)) (type-spec (struct-def (ident ,name) ,field-list))) (init-declr-list (init-declr (ident ,name))))))

        ((decl (decl-spec-list (stor-spec (typedef)) (type-spec (union-def ,field-list))) (init-declr-list (init-declr (ident ,name))))
         ((decl->info info) `(decl (decl-spec-list (stor-spec (typedef)) (type-spec (union-def (ident ,name) ,field-list))) (init-declr-list (init-declr (ident ,name))))))

        ((decl (decl-spec-list (stor-spec (typedef)) (type-spec (struct-def (ident ,type) ,field-list))) (init-declr-list (init-declr (ident ,name))))
         (let* ((info ((decl->info info) `(decl (decl-spec-list (type-spec (struct-def (ident ,type) ,field-list))))))
                (types (.types info)))
           (clone info #:types (cons (cons name (or (get-type types `("tag" ,type)) `(typedef ,type))) types))))

        ((decl (decl-spec-list (stor-spec (typedef)) (type-spec (union-def (ident ,type) ,field-list))) (init-declr-list (init-declr (ident ,name))))
         (let* ((info ((decl->info info) `(decl (decl-spec-list (type-spec (union-def (ident ,type) ,field-list))))))
                (types (.types info)))
           (clone info #:types (cons (cons name (or (get-type types `("tag" ,type)) `(typedef ,type))) types))))

        ((decl (decl-spec-list (stor-spec (typedef)) (type-spec (fixed-type ,type))) (init-declr-list (init-declr (ptr-declr (pointer) (ident ,name)))))
         (let* ((type (get-type types type))
                (type (make-type (type:type type)
                                 (type:size type)
                                 (1+ (type:pointer type))
                                 (type:description type)))
                (type-entry (cons name type)))
           (clone info #:types (cons type-entry types))))

        ;; struct
        ((decl (decl-spec-list (type-spec (struct-def (ident ,name) (field-list . ,fields)))))
         (let ((type-entry (struct->type-entry name (map (struct-field info) fields))))
           (clone info #:types (cons type-entry types))))

        ;; union
        ((decl (decl-spec-list (type-spec (union-def (ident ,name) (field-list . ,fields)))))
         (let ((type-entry (union->type-entry name (map (struct-field info) fields))))
           (clone info #:types (cons type-entry types))))

        ;; enum e i;
        ((decl (decl-spec-list (type-spec (enum-ref (ident ,type)))) (init-declr-list (init-declr (ident ,name))))
         (let ((type "int")) ;; FIXME
           (if (.function info)
               (clone info #:locals (add-local locals name type 0))
               (clone info #:globals (append globals (list (ident->global-entry name type 0 0)))))))

        ;; struct foo bar[2];
        ;; char arena[20000];
        ((decl (decl-spec-list (type-spec ,type)) (init-declr-list (init-declr (array-of (ident ,name) ,count))))
         (let ((type (ast->type type)))
           (if (.function info)
               (let* ((local (car (add-local locals name type -1)))
                      (count (expr->number info count))
                      (size (ast-type->size info type))
                      (pointer (expr->pointer info `(type-spec ,type)))
                      (pointer (- -1 pointer))
                      (local (pke "0local: " (make-local-entry name type pointer (+ (local:id (cdr local)) -1 (quotient (+ (* count size) 3) 4)))))
                      (locals (cons local locals))
                      (info (clone info #:locals locals)))
                 info)
               (let* ((foo (mescc:trace name " <g>"))
                      (globals (.globals info))
                      (count (expr->number info count))
                      (size (ast-type->size info type))
                      (pointer (expr->pointer info `(type-spec ,type)))
                      (pointer (- -1 pointer))
                      (array (pke "0global: " (make-global-entry name type pointer (string->list (make-string (* count size) #\nul)))))
                      (globals (append globals (list array))))
                 (clone info #:globals globals)))))

        ;; struct foo *bar[2];
        ((decl (decl-spec-list (type-spec ,type)) (init-declr-list (init-declr (ptr-declr (pointer) (array-of (ident ,name) ,count)))))
         (let ((type (ast->type type)))
           (if (.function info)
               (let* ((local (car (add-local locals name type -1)))
                      (count (expr->number info count))
                      (size 4)
                      (pointer (expr->pointer info `(type-spec ,type)))
                      (pointer (- -3 pointer))
                      (local (pke "1local:" (make-local-entry name type pointer (+ (local:id (cdr local)) -1 (quotient (+ (* count size) 3) 4)))))
                      (locals (cons local locals))
                      (info (clone info #:locals locals)))
                 info)
               (let* ((foo (mescc:trace name " <g>"))
                      (globals (.globals info))
                      (count (expr->number info count))
                      (size 4)
                      (pointer (expr->pointer info `(type-spec ,type)))
                      (pointer (- -3 pointer))
                      (global (pke "1global: " (make-global-entry name type pointer (string->list (make-string (* count size) #\nul)))))
                      (globals (append globals (list global))))
                 (clone info #:globals globals)))))

        ((decl (decl-spec-list (type-spec (fixed-type ,type))) (init-declr-list (init-declr (array-of (ident ,name) (p-expr (fixed ,size))) (initzer (p-expr (string ,string))))))
         (if (.function info)
             (error  "TODO: " o)
             (let* ((foo (mescc:trace name " <g>"))
                    (globals (.globals info))
                    ;; (count (cstring->number count))
                    ;; (size (ast-type->size info type))
                    (array (make-global-entry name type -1 (string->list string)))
                    (globals (append globals (list array))))
               (clone info #:globals globals))))

        ;; int (*function) (void) = g_functions[g_cells[fn].cdr].function;
        ((decl (decl-spec-list (type-spec (fixed-type ,type))) (init-declr-list (init-declr (ftn-declr (scope (ptr-declr (pointer) (ident ,name))) (param-list . ,param-list)) (initzer ,initzer))))
         (let* ((locals (add-local locals name type 1))
                (info (clone info #:locals locals))
                (empty (clone info #:text '()))
                (accu ((expr->accu empty) initzer)))
           (clone info
                  #:text
                  (append text
                          (.text accu)
                          ((accu->ident info) name)
                          (wrap-as (append (i386:label->base `(#:address "_start"))
                                           (i386:accu+base))))
                  #:locals locals)))

        ;; char *p = g_cells;
        ((decl (decl-spec-list (type-spec ,type)) (init-declr-list (init-declr (ptr-declr (pointer) (ident ,name)) (initzer (p-expr (ident ,value))))))
         (let ((info (append-text info (ast->comment o)))
               (type (decl->ast-type type)))
           (if (.function info)
               (let* ((locals (add-local locals name type  1))
                      (info (clone info #:locals locals)))
                 (append-text info (append ((ident->accu info) value)
                                           ((accu->ident info) name))))
               (let ((globals (append globals (list (ident->global-entry name type 1 `(,value #f #f #f))))))
                 (clone info #:globals globals)))))

        ;; enum foo { };
        ((decl (decl-spec-list (type-spec (enum-def (ident ,name) (enum-def-list . ,fields)))))
         (let ((type-entry (enum->type-entry name fields))
               (constants (enum-def-list->constants constants fields)))
           (clone info
                  #:types (cons type-entry types)
                  #:constants (append constants (.constants info)))))

        ;; enum {};
        ((decl (decl-spec-list (type-spec (enum-def (enum-def-list . ,fields)))))
         (let ((constants (enum-def-list->constants constants fields)))
           (clone info
                  #:constants (append constants (.constants info)))))

        ((decl (decl-spec-list (type-spec (struct-def (ident ,type) (field-list . ,fields))))
               (init-declr-list (init-declr (ident ,name))))
         (let ((info ((decl->info info) `(decl (decl-spec-list (type-spec (struct-def (ident ,type) (field-list . ,fields))))))))
           ((decl->info info) `(decl (decl-spec-list (type-spec (struct-ref (ident ,type)))) (init-declr-list (init-declr (ident ,name)))))))

        ((decl (decl-spec-list (stor-spec (typedef)) (type-spec (union-def (ident ,type) ,fields))) (init-declr-list (init-declr (ident ,name))))
         (let ((info ((decl->info info) `(decl (decl-spec-list (type-spec (union-def (ident ,type) ,fields)))))))
           ((decl->info info) `(decl (decl-spec-list (type-spec (union-ref (ident ,type)))) (init-declr-list (init-declr (ident ,name)))))))

        ;; struct f = {...};
        ;; LOCALS!
        ((decl (decl-spec-list (type-spec ,type)) (init-declr-list (init-declr (ident ,name) (initzer (initzer-list . ,initzers)))))
         (if (not (.function info)) (mescc:trace name " <g>"))
         (let* ((info (append-text info (ast->comment o)))
                (type (decl->ast-type type))
                (fields (ast-type->description info type))
                (xtype (ast-type->type info type))
                (fields (if (not (eq? (type:type xtype) 'union)) fields
                            (list-head fields 1)))
                (size (ast-type->size info type))
                (initzers (map (initzer->non-const info) initzers)))
           (if (.function info)
               (let* ((initzer-globals (filter identity (append-map (initzer->globals globals) initzers)))
                      (global-names (map car globals))
                      (initzer-globals (filter (lambda (g) (and g (not (member (car g) global-names)))) initzer-globals))
                      (globals (append globals initzer-globals))
                      (local (car (add-local locals name type -1)))
                      (local (make-local-entry name type -1 (+ (local:id (cdr local)) (quotient (+ size 3) 4))))
                      (locals (cons local locals))
                      (info (clone info #:locals locals #:globals globals))
                      (empty (clone info #:text '())))
                 (let loop ((fields fields) (initzers initzers) (info info))
                   (if (null? fields) info
                       (let ((offset (field-offset info type (field:name (car fields))))
                             (size (field:size (car fields)))
                             (initzer (if (null? initzers) '(p-expr (fixed "0")) (car initzers))))
                         (loop (cdr fields) (if (null? initzers) '() (cdr initzers))
                               (clone info #:text
                                      (append
                                       (.text info)
                                       ((ident->accu info) name)
                                       (wrap-as (append (i386:accu->base)))
                                       (.text ((expr->accu empty) initzer))
                                       (wrap-as (case size
                                                  ((1) (i386:byte-accu->base-mem+n offset))
                                                  ((2) (i386:word-accu->base-mem+n offset))
                                                  (else (i386:accu->base-mem+n offset)))))))))))
               (let* ((initzer-globals (filter identity (append-map (initzer->globals globals) initzers)))
                      (global-names (map car globals))
                      (initzer-globals (filter (lambda (g) (and g (not (member (car g) global-names)))) initzer-globals))
                      (globals (append globals initzer-globals))
                      (global (make-global-entry name type -1 (append-map (initzer->data info) initzers)))
                      (globals (append globals (list global))))
                 (clone info #:globals globals)))))

        ;; DECL
        ;; char *bla[] = {"a", "b"};
        ((decl (decl-spec-list (type-spec ,type)) (init-declr-list (init-declr (ptr-declr (pointer) (array-of (ident ,name))) (initzer (initzer-list . ,initzers)))))
         (if (not (.function info)) (mescc:trace name " <g>"))
         (let* ((type (decl->ast-type type))
                (pointer (pke "2pointer: " (expr->pointer info `(type-spec ,type))))
                (pointer (pke "pointer: " (- -3 pointer)))
                (entries (filter identity (append-map (initzer->globals globals) initzers)))
                (global-names (map car globals))
                (entries (filter (lambda (g) (and g (not (member (car g) global-names)))) entries))
                (globals (append globals entries))
                (entry-size 4)
                (size (* (length entries) entry-size))
                (initzers (map (initzer->non-const info) initzers)))
           (if (.function info)
               (let* ((count (length initzers))
                      (local (car (add-local locals name type -1)))
                      (local (pke "2local: " (make-local-entry name type pointer (+ (local:id (cdr local)) -1 (1+ count)))))
                      (locals (cons local locals))
                      (info (clone info #:locals locals))
                      (info (clone info #:globals globals))
                      (empty (clone info #:text '())))
                 (let loop ((index 0) (initzers initzers) (info info))
                   (if (null? initzers) info
                       (let ((offset (* index 4))
                             (initzer (car initzers)))
                         (loop (1+ index) (cdr initzers)
                               (clone info #:text
                                      (append
                                       (.text info)
                                       ((ident->accu info) name)
                                       (wrap-as (append (i386:accu->base)))
                                       (.text ((expr->accu empty) initzer))
                                       (wrap-as (i386:accu->base-mem+n offset)))))))))
               (let* ((global (pke "2global: " (make-global-entry name type pointer (append-map (initzer->data info) initzers))))
                      (globals (append globals (list global))))
                 (clone info #:globals globals)))))

        ;; int foo[2] = { ... }
        ((decl (decl-spec-list (type-spec ,type)) (init-declr-list (init-declr (array-of (ident ,name) ,count) (initzer (initzer-list . ,initzers)))))
         (if (not (.function info)) (mescc:trace name " <g>"))
         (let* ((info (type->info info type))
                (xtype type)
                (type (decl->ast-type type))
                (pointer (expr->pointer info `(type-spec ,type)))
                (pointer (- -2 pointer))
                (initzer-globals (filter identity (append-map (initzer->globals globals) initzers)))
                (global-names (map car globals))
                (initzer-globals (filter (lambda (g) (and g (not (member (car g) global-names)))) initzer-globals))
                (initzers ((initzer->non-const info) initzers))
                (info (append-text info (ast->comment o)))
                (globals (append globals initzer-globals))
                (info (clone info #:globals globals))
                (type-size (if (<= pointer 0) (ast-type->size info type)
                               4))
                (count (expr->number info count))
                (size (* count type-size)))
           (if (.function info)
               (let* ((local (car (add-local locals name type 1)))
                      (local (pke "3local: " (make-local-entry name type pointer (+ (local:id (cdr local)) -1 (quotient (+ size 3) 4)))))
                      (locals (cons local locals))
                      (local (cdr local))
                      (info (clone info #:locals locals))
                      (info (let loop ((info info) (initzers initzers) (n 0))
                              (if (null? initzers) info
                                  (let* ((info ((initzer->accu info) (car initzers)))
                                         (info ((accu->local+n info local) n)))
                                    (loop info (cdr initzers) (+ n type-size)))))))
                 info)
               (let* ((global (pke "3global:" (make-global-entry name type pointer (append-map (initzer->data info) initzers))))
                      (globals (append globals (list global))))
                 (clone info #:globals globals)))))

        ((decl (decl-spec-list (type-spec ,type)) (init-declr-list (init-declr ,init . ,initzer)))
         (let* ((info (type->info info type))
                (xtype type)
                (type (decl->ast-type type))
                (name (init-declr->name init))
                (foo (if (not (.function info)) (mescc:trace name " <g>")))
                (pointer (init-declr->pointer init))
                (initzer-globals (if (null? initzer) '()
                                     (filter identity (append-map (initzer->globals globals) initzer))))
                (global-names (map car globals))
                (initzer-globals (filter (lambda (g) (and g (not (member (car g) global-names)))) initzer-globals))
                (initzer (if (null? initzer) '() ((initzer->non-const info) initzer)))
                ;;FIXME: ridiculous performance hit with mes
                (info (append-text info (ast->comment o)))
                (globals (append globals initzer-globals))
                (info (clone info #:globals globals))
                (struct? (and (zero? pointer)
                              (or (and (pair? type) (equal? (car type) "tag"))
                                  (memq (type:type (ast-type->type info xtype)) '(struct union)))))
                (pointer (if struct? -1 pointer))
                (size (if (<= pointer 0) (ast-type->size info type)
                          4))
                (count (init-declr->count info init)) ; array... split me up?
                (size (if count (* count size) size)))
           (if (.function info)
               (let* ((locals (if (or (> pointer 0) (<= size 4)) (add-local locals name type pointer)
                                  (let* ((local (car (add-local locals name type 1)))
                                         (local (pke "4local:" (make-local-entry name type pointer (+ (local:id (cdr local)) -1 (quotient (+ size 3) 4))))))
                                    (cons local locals))))
                      (info (clone info #:locals locals))
                      (info (if (null? initzer) info ((initzer->accu info) (car initzer))))
                      ;; FIXME array...struct?
                      (info (if (null? initzer) info (append-text info ((accu->ident info) name)))))
                 info)
               (let* ((global (pke "4global:" (make-global-entry name type pointer (if (null? initzer) (string->list (make-string size #\nul))
                                                                        (append-map (initzer->data info) initzer)))))
                      (globals (append globals (list global))))
                 (clone info #:globals globals)))))

        ;; int i = 0, j = 0;
        ((decl (decl-spec-list (type-spec ,type)) (init-declr-list (init-declr (ident ,name) . ,initzer) . ,rest))
         (let loop ((inits `((init-declr (ident ,name) ,@initzer) ,@rest)) (info info))
           (if (null? inits) info
               (loop (cdr inits)
                     ((decl->info info)
                      `(decl (decl-spec-list (type-spec ,type)) (init-declr-list ,(car inits))))))))

        ;; int *i = 0, j ..;
        ((decl (decl-spec-list (type-spec ,type)) (init-declr-list (init-declr (ptr-declr ,pointer (ident ,name)) . ,initzer) . ,rest))
         (let loop ((inits `((init-declr (ptr-declr ,pointer (ident ,name)) ,@initzer) ,@rest)) (info info))
           (if (null? inits) info
               (loop (cdr inits)
                     ((decl->info info)
                      `(decl (decl-spec-list (type-spec ,type)) (init-declr-list ,(car inits))))))))

        ((decl (decl-spec-list (stor-spec (typedef)) ,type) ,name)
         (format (current-error-port) "SKIP: typedef=~s\n" o)
         info)

        ((decl (@ ,at))
         (format (current-error-port) "SKIP: at=~s\n" o)
         info)

        ((decl . _) (error "decl->info: unsupported: " o))))))

(define (ast->info info)
  (lambda (o)
    (let ((functions (.functions info))
          (globals (.globals info))
          (locals (.locals info))
          (constants (.constants info))
          (types (.types info))
          (text (.text info)))
      (pmatch o
        (((trans-unit . _) . _)
         ((ast-list->info info)  o))
        ((trans-unit . ,elements)
         ((ast-list->info info) elements))
        ((fctn-defn . _) ((function->info info) o))
        ((cpp-stmt (define (name ,name) (repl ,value)))
         info)

        ((cast (type-name (decl-spec-list (type-spec (void)))) _)
         info)

        ((break)
         (let ((label (car (.break info))))
           (append-text info (wrap-as (i386:jump label)))))

        ((continue)
         (let ((label (car (.continue info))))
           (append-text info (wrap-as (i386:jump label)))))

        ;; FIXME: expr-stmt wrapper?
        (trans-unit info)
        ((expr-stmt) info)

        ((compd-stmt (block-item-list . ,statements)) ((ast-list->info info) statements))

        ((asm-expr ,gnuc (,null ,arg0 . string))
         (append-text info (wrap-as (asm->m1 arg0))))

        ((expr-stmt (fctn-call (p-expr (ident ,name)) (expr-list . ,expr-list)))
         (if (equal? name "asm") (let ((arg0 (cadr (cadar expr-list))))
                                   (append-text info (wrap-as (asm->m1 arg0))))
             (let* ((info (append-text info (ast->comment o)))
                    (info ((expr->accu info) `(fctn-call (p-expr (ident ,name)) (expr-list . ,expr-list)))))
               (append-text info (wrap-as (i386:accu-zero?))))))

        ((if ,test ,then)
         (let* ((info (append-text info (ast->comment `(if ,test (ellipsis)))))
                (here (number->string (length text)))
                (label (string-append "_" (.function info) "_" here "_"))
                (break-label (string-append label "break"))
                (else-label (string-append label "else"))
                (info ((test-jump-label->info info break-label) test))
                (info ((ast->info info) then))
                (info (append-text info (wrap-as (i386:jump break-label))))
                (info (append-text info (wrap-as `((#:label ,break-label))))))
           (clone info
                  #:locals locals)))

        ((if ,test ,then ,else)
         (let* ((info (append-text info (ast->comment `(if ,test (ellipsis) (ellipsis)))))
                (here (number->string (length text)))
                (label (string-append "_" (.function info) "_" here "_"))
                (break-label (string-append label "break"))
                (else-label (string-append label "else"))
                (info ((test-jump-label->info info else-label) test))
                (info ((ast->info info) then))
                (info (append-text info (wrap-as (i386:jump break-label))))
                (info (append-text info (wrap-as `((#:label ,else-label)))))
                (info ((ast->info info) else))
                (info (append-text info (wrap-as `((#:label ,break-label))))))
           (clone info
                  #:locals locals)))

        ;; Hmm?
        ((expr-stmt (cond-expr ,test ,then ,else))
         (let* ((info (append-text info (ast->comment `(cond-expr ,test (ellipsis) (ellipsis)))))
                (here (number->string (length text)))
                (label (string-append "_" (.function info) "_" here "_"))
                (else-label (string-append label "else"))
                (break-label (string-append label "break"))
                (info ((test-jump-label->info info else-label) test))
                (info ((ast->info info) then))
                (info (append-text info (wrap-as (i386:jump break-label))))
                (info (append-text info (wrap-as `((#:label ,else-label)))))
                (info ((ast->info info) else))
                (info (append-text info (wrap-as `((#:label ,break-label))))))
           info))

        ((switch ,expr (compd-stmt (block-item-list . ,statements)))
         (let* ((info (append-text info (ast->comment `(switch ,expr (compd-stmt (block-item-list (ellipsis)))))))
                (here (number->string (length text)))
                (label (string-append "_" (.function info) "_" here "_"))
                (break-label (string-append label "break"))
                (clauses (statements->clauses statements))
                (info ((expr->accu info) expr))
                (info (clone info #:break (cons break-label (.break info))))
                (info (let loop ((clauses clauses) (i 0) (info info))
                        (if (null? clauses) info
                            (loop (cdr clauses) (1+ i) ((clause->info info i label (null? (cdr clauses))) (car clauses))))))
                (info (append-text info (wrap-as `((#:label ,break-label))))))
           (clone info
                  #:locals locals
                  #:break (cdr (.break info)))))

        ((for ,init ,test ,step ,body)
         (let* ((info (append-text info (ast->comment `(for ,init ,test ,step (ellipsis)))))
                (here (number->string (length text)))
                (label (string-append "_" (.function info) "_" here "_"))
                (break-label (string-append label "break"))
                (loop-label (string-append label "loop"))
                (continue-label (string-append label "continue"))
                (initial-skip-label (string-append label "initial_skip"))
                (info ((ast->info info) init))
                (info (clone info #:break (cons break-label (.break info))))
                (info (clone info #:continue (cons continue-label (.continue info))))
                (info (append-text info (wrap-as (i386:jump initial-skip-label))))
                (info (append-text info (wrap-as `((#:label ,loop-label)))))
                (info ((ast->info info) body))
                (info (append-text info (wrap-as `((#:label ,continue-label)))))
                (info ((expr->accu info) step))
                (info (append-text info (wrap-as `((#:label ,initial-skip-label)))))
                (info ((test-jump-label->info info break-label) test))
                (info (append-text info (wrap-as (i386:jump loop-label))))
                (info (append-text info (wrap-as `((#:label ,break-label))))))
           (clone info
                  #:locals locals
                  #:break (cdr (.break info))
                  #:continue (cdr (.continue info)))))

        ((while ,test ,body)
         (let* ((info (append-text info (ast->comment `(while ,test (ellipsis)))))
                (here (number->string (length text)))
                (label (string-append "_" (.function info) "_" here "_"))
                (break-label (string-append label "break"))
                (loop-label (string-append label "loop"))
                (continue-label (string-append label "continue"))
                (info (append-text info (wrap-as (i386:jump continue-label))))
                (info (clone info #:break (cons break-label (.break info))))
                (info (clone info #:continue (cons continue-label (.continue info))))
                (info (append-text info (wrap-as `((#:label ,loop-label)))))
                (info ((ast->info info) body))
                (info (append-text info (wrap-as `((#:label ,continue-label)))))
                (info ((test-jump-label->info info break-label) test))
                (info (append-text info (wrap-as (i386:jump loop-label))))
                (info (append-text info (wrap-as `((#:label ,break-label))))))
           (clone info
                  #:locals locals
                  #:break (cdr (.break info))
                  #:continue (cdr (.continue info)))))

        ((do-while ,body ,test)
         (let* ((info (append-text info (ast->comment `(do-while ,test (ellipsis)))))
                (here (number->string (length text)))
                (label (string-append "_" (.function info) "_" here "_"))
                (break-label (string-append label "break"))
                (loop-label (string-append label "loop"))
                (continue-label (string-append label "continue"))
                (info (clone info #:break (cons break-label (.break info))))
                (info (clone info #:continue (cons continue-label (.continue info))))
                (info (append-text info (wrap-as `((#:label ,loop-label)))))
                (info ((ast->info info) body))
                (info (append-text info (wrap-as `((#:label ,continue-label)))))
                (info ((test-jump-label->info info break-label) test))
                (info (append-text info (wrap-as (i386:jump loop-label))))
                (info (append-text info (wrap-as `((#:label ,break-label))))))
           (clone info
                  #:locals locals
                  #:break (cdr (.break info))
                  #:continue (cdr (.continue info)))))

        ((labeled-stmt (ident ,label) ,statement)
         (let ((info (append-text info `(((#:label ,(string-append "_" (.function info) "_label_" label)))))))
           ((ast->info info) statement)))

        ((goto (ident ,label))
         (append-text info (wrap-as (i386:jump (string-append "_" (.function info) "_label_" label)))))

        ((return ,expr)
         (let ((info ((expr->accu info) expr)))
           (append-text info (append (wrap-as (i386:ret))))))

        ((decl . ,decl)
         ((decl->info info) o))

        ;; ...
        ((gt . _) ((expr->accu info) o))
        ((ge . _) ((expr->accu info) o))
        ((ne . _) ((expr->accu info) o))
        ((eq . _) ((expr->accu info) o))
        ((le . _) ((expr->accu info) o))
        ((lt . _) ((expr->accu info) o))
        ((lshift . _) ((expr->accu info) o))
        ((rshift . _) ((expr->accu info) o))

        ;; EXPR
        ((expr-stmt ,expression)
         (let ((info ((expr->accu info) expression)))
           (append-text info (wrap-as (i386:accu-zero?)))))

        ;; FIXME: why do we get (post-inc ...) here
        ;; (array-ref
        (_ (let ((info ((expr->accu info) o)))
             (append-text info (wrap-as (i386:accu-zero?)))))))))

(define (enum-def-list->constants constants fields)
  (let loop ((fields fields) (i 0) (constants constants))
    (if (pair? fields)
        (let ((field (car fields)))
          (mescc:trace (cadr (cadr field)) " <e>")))
    (if (null? fields) constants
        (let* ((field (car fields))
               (name (pmatch field
                       ((enum-defn (ident ,name) . _) name)))
               (i (pmatch field
                    ((enum-defn ,name) i)
                    ((enum-defn ,name ,exp) (expr->number #f exp))
                    (_ (error "not supported enum field=~s\n" field)))))
          (loop (cdr fields)
                (1+ i)
                (append constants (list (ident->constant name i))))))))

(define (initzer->non-const info)
  (lambda (o)
    (pmatch o
      ((initzer (p-expr (ident ,name)))
       (let ((value (assoc-ref (.constants info) name)))
         `(initzer (p-expr (fixed ,(number->string value))))))
      (_ o))))

(define (initzer->value info)
  (lambda (o)
    (pmatch o
      ((p-expr (fixed ,value)) (cstring->number value))
      (_ (error "initzer->value: " o)))))

(define (initzer->data info)
  (lambda (o)
    (pmatch o
      ((initzer (p-expr (char ,char))) (int->bv32 (char->integer (string-ref char 0))))
      ((initzer (p-expr (char ,char))) (list (char->integer (string-ref char 0))))
      ((initzer (p-expr (string ,string))) `((#:string ,string) #f #f #f))
      ((initzer (p-expr (string . ,strings))) `((#:string ,(string-join strings "")) #f #f #f))
      ((initzer (initzer-list . ,initzers)) (append-map (initzer->data info) initzers))
      ((initzer (ref-to (p-expr (ident ,name)))) `(,name #f #f #f))
      ((initzer (ref-to (i-sel (ident ,field) (cast (type-name (decl-spec-list ,struct) (abs-declr (pointer))) (p-expr (fixed ,base))))))
       (let* ((type (decl->ast-type struct))
              (offset (field-offset info type field))
              (base (cstring->number base)))
         (int->bv32 (+ base offset))))
      (() (int->bv32 0))
      ((initzer ,p-expr)
       (int->bv32 (expr->number info p-expr)))
      (_ (error "initzer->data: unsupported: " o)))))

(define (initzer->accu info)
  (lambda (o)
    (pmatch o
      ((initzer-list . ,initzers) (fold (lambda (i info) ((expr->accu info) i)) info initzers))
      ((initzer (initzer-list . ,initzers)) (fold (lambda (i info) ((expr->accu info) i)) info initzers))
      ((initzer ,initzer) ((expr->accu info) o))
      (() (append-text info (wrap-as (i386:value->accu 0))))
      (_ (error "initzer->accu: " o)))))

(define (expr->global globals)
  (lambda (o)
    (pmatch o
      ((p-expr (string ,string))
       (let ((g `(#:string ,string)))
         (or (assoc g globals)
             (string->global-entry string))))
      ((p-expr (string . ,strings))
       (let* ((string (string-join strings ""))
              (g `(#:string ,string)))
         (or (assoc g globals)
             (string->global-entry string))))
      ;;((p-expr (fixed ,value)) (int->global-entry (cstring->number value)))
      (_ #f))))

(define (initzer->globals globals)
  (lambda (o)
    (pmatch o
      ((initzer (initzer-list . ,initzers)) (append-map (initzer->globals globals) initzers))
      ((initzer ,initzer) (list ((expr->global globals) initzer)))
      (_ '(#f)))))

(define (type->info info o)
  (pmatch o
    ((struct-def (ident ,name) (field-list . ,fields))
     (mescc:trace name " <t>")
     (let ((type-entry (struct->type-entry name (map (struct-field info) fields))))
       (clone info #:types (cons type-entry (.types info)))))
    (_  info)))

(define (.formals o)
  (pmatch o
    ((fctn-defn _ (ftn-declr _ ,formals) _) formals)
    ((fctn-defn _ (ptr-declr (pointer) (ftn-declr _ ,formals)) _) formals)
    ((fctn-defn _ (ptr-declr (pointer (pointer)) (ftn-declr _ ,formals)) _) formals)
    ((fctn-defn _ (ptr-declr (pointer (pointer (pointer))) (ftn-declr _ ,formals)) _) formals)
    (_ (error ".formals: " o))))

(define (formal->text n)
  (lambda (o i)
    ;;(i386:formal i n)
    '()
    ))

(define (formals->text o)
  (pmatch o
    ((param-list . ,formals)
     (let ((n (length formals)))
       (wrap-as (append (i386:function-preamble)
                        (append-map (formal->text n) formals (iota n))
                        (i386:function-locals)))))
    (_ (error "formals->text: unsupported: " o))))

(define (formal:ptr o)
  (pmatch o
    ((param-decl (decl-spec-list . ,decl) (param-declr (ident ,name)))
     0)
    ((param-decl (decl-spec-list . ,decl) (param-declr (ptr-declr (pointer) (array-of (ident ,name)))))
     2)
    ((param-decl (decl-spec-list . ,decl) (param-declr (ptr-declr (pointer) (ident ,name))))
     1)
    ((param-decl (decl-spec-list . ,decl) (param-declr (ptr-declr (pointer) . _)))
     1)
    ((param-decl (decl-spec-list . ,decl) (param-declr (ptr-declr (pointer (pointer)) (ident ,name))))
     2)
    ((param-decl (decl-spec-list . ,decl) (param-declr (ptr-declr (pointer (pointer (pointer))) (ident ,name))))
     3)
    (_ 0)))

(define (formals->locals o)
  (pmatch o
    ((param-list . ,formals)
     (let ((n (length formals)))
       (map make-local-entry (map .name formals) (map .type formals) (map formal:ptr formals) (iota n -2 -1))))
    (_ (error "formals->locals: unsupported: " o))))

(define (function->info info)
  (lambda (o)
    (define (assert-return text)
      (let ((return (wrap-as (i386:ret))))
        (if (equal? (list-tail text (- (length text) (length return))) return) text
            (append text return))))
    (let* ((name (.name o))
           (formals (.formals o))
           (text (formals->text formals))
           (locals (formals->locals formals)))
      (mescc:trace name)
      (let loop ((statements (.statements o))
                 (info (clone info #:locals locals #:function (.name o) #:text text)))
        (if (null? statements) (let* ((locals (.locals info))
                                      (local (and (pair? locals) (car locals)))
                                      (count (and=> local (compose local:id cdr)))
                                      (stack (and count (* count 4))))
                                 (if (and stack (getenv "MESC_DEBUG")) (stderr "        stack: ~a\n" stack))
                                 (clone info
                                       #:function #f
                                       #:functions (append (.functions info) (list (cons name (assert-return (.text info)))))))
            (let* ((statement (car statements)))
              (loop (cdr statements)
                    ((ast->info info) (car statements)))))))))

;; exports

(define (ast-list->info info)
  (lambda (elements)
    (let loop ((elements elements) (info info))
      (if (null? elements) info
          (loop (cdr elements) ((ast->info info) (car elements)))))))

(define* (c99-ast->info ast)
  ((ast->info (make <info> #:types i386:type-alist)) ast))

(define* (c99-input->ast #:key (defines '()) (includes '()))
  (stderr "parsing: input\n")
  ((compose ast-strip-const ast-strip-comment) (c99-input->full-ast #:defines defines #:includes includes)))

(define* (c99-input->info #:key (defines '()) (includes '()))
  (lambda ()
    (let* ((info (make <info> #:types i386:type-alist))
           (ast (c99-input->ast #:defines defines #:includes includes))
           (foo (stderr "compiling: input\n"))
           (info ((ast->info info) ast))
           (info (clone info #:text '() #:locals '())))
      info)))

(define* (info->object o)
  (stderr "compiling: object\n")
  `((functions . ,(.functions o))
    (globals . ,(map (lambda (g) (cons (car g) (global:value (cdr g)))) (.globals o)))))

(define* (c99-input->elf #:key (defines '()) (includes '()))
  ((compose object->elf info->object (c99-input->info #:defines defines #:includes includes))))

(define* (c99-input->object #:key (defines '()) (includes '()))
  ((compose object->M1 info->object (c99-input->info #:defines defines #:includes includes))))
