;;; -*-scheme-*-

;;; Mes --- Maxwell Equations of Software
;;; Copyright Â© 2016,2017 Jan Nieuwenhuizen <janneke@gnu.org>
;;;
;;; This file is part of Mes.
;;;
;;; Mes is free software; you can redistribute it and/or modify it
;;; under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 3 of the License, or (at
;;; your option) any later version.
;;;
;;; Mes is distributed in the hope that it will be useful, but
;;; WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with Mes.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;;; compiler.mes produces an i386 binary from the C produced by
;;; Nyacc c99.

;;; Code:

(cond-expand
 (guile-2
  (set-port-encoding! (current-output-port) "ISO-8859-1"))
 (guile)
 (mes
  (mes-use-module (nyacc lang c99 parser))
  (mes-use-module (mes elf-util))
  (mes-use-module (mes pmatch))
  (mes-use-module (mes elf))
  (mes-use-module (mes libc-i386))))

(define (logf port string . rest)
  (apply format (cons* port string rest))
  (force-output port)
  #t)

(define (stderr string . rest)
  (apply logf (cons* (current-error-port) string rest)))

(define (gnuc-xdef? name mode) (if (equal? name "__GNUC__") #f (eq? mode 'code)))
;;(define (gnuc-xdef? name mode) (equal? name "__GNUC__"))
;; (define (gnuc-xdef? name mode)
;;   (cond ((equal? name "__GNUC__") #t)
;;         ((equal? name "asm") #f)))

(define (mescc)
  (parse-c99 #:inc-dirs (string-split (getenv "C_INCLUDE_PATH") #\:)
             #:cpp-defs '(("__GNUC__" . "0") ("__NYACC__" . "1"))
             #:xdef? gnuc-xdef?
             #:mode 'code
             ))

(define (write-any x)
  (write-char (cond ((char? x) x)
                    ((number? x) (integer->char (if (>= x 0) x (+ x 256))))
                    (else (stderr "write-any: ~a\n" x) barf))))

(define (ast:function? o)
  (and (pair? o) (eq? (car o) 'fctn-defn)))

(define (.name o)
  (pmatch o
    ((fctn-defn _ (ftn-declr (ident ,name) _) _) name)
    ((fctn-defn _ (ptr-declr (pointer) (ftn-declr (ident ,name) _)) _) name)
    ((param-decl _ (param-declr (ident ,name))) name)
    ((param-decl _ (param-declr (ptr-declr (pointer) (ident ,name)))) name)
    ((param-decl _ (param-declr (ptr-declr (pointer) (array-of (ident ,name))))) name)
    (_
     (format (current-error-port) "SKIP .name =~a\n" o))))

(define (.statements o)
  (pmatch o
    ((fctn-defn _ (ftn-declr (ident ,name) _) (compd-stmt (block-item-list . ,statements))) statements)
    ((fctn-defn _ (ptr-declr (pointer) (ftn-declr (ident ,name) _)) (compd-stmt (block-item-list . ,statements))) statements)))

(define (ident-ref locals)
  (lambda (o)
    ;; (stderr "IDENT REF[~a]: ~a => ~a\n" o (assoc-ref locals o) (i386:ref-local (assoc-ref locals o)))
    (i386:ref-local (assoc-ref locals o))))

(define (global-ref globals)
  (lambda (o)
    (lambda (s t d)
      (i386:ref-global (+ (data-offset o globals) d)))))

(define (expr->arg globals locals) ;; FIXME: get Mes curried-definitions
  (lambda (o)
    (pmatch o
      ((p-expr (fixed ,value)) (string->number value))
      ((p-expr (string ,string)) ((global-ref globals) string))
      ((p-expr (ident ,name)) ((ident-ref locals) name))

      ((array-ref (p-expr (fixed ,value)) (p-expr (ident ,name)))
       (let ((value (string->number value))
             (size 4)) ;; FIXME: type: int
         (lambda (s t d)
           (append
            ((ident->base locals) name)
            (i386:value->accu (* size value)) ;; FIXME: type: int
            (i386:mem->accu) ;; FIXME: type: int
            (i386:push-accu) ;; hmm
            ))))

      (_
       (format (current-error-port) "SKIP expr->arg=~a\n" o)     
       0))))

(define (ident->accu locals)
  (lambda (o)
    (i386:local->accu (assoc-ref locals o))))

(define (accu->ident locals)
  (lambda (o)
    (i386:accu->local (assoc-ref locals o))))

(define (ident->base locals)
  (lambda (o)
    (i386:local->base (assoc-ref locals o))))

;; (define (global-accu globals)
;;   (lambda (o)
;;     (lambda (s t d)
;;       (i386:accu-global (+ (data-offset o globals) d)))))

(define (expr->accu globals locals)
  (lambda (o)
    (pmatch o
      ((p-expr (fixed ,value)) (string->number value))
      ((p-expr (ident ,name)) ((ident->accu locals) name))
      (_
       (format (current-error-port) "SKIP expr-accu=~a\n" o)
       0)
      )))

(define (expr->globals o)
  (pmatch o
    ((p-expr (string ,string)) (string->globals string))
    (_ #f)))

(define make-text+globals+locals cons*)
(define .text car)
(define .globals cadr)
(define .locals cddr)

(define (dec->hex o)
  (number->string o 16))

(define (text->list o)
  (append-map (lambda (f) (f '() 0 0)) o))

(define (byte->hex o)
  (string->number (string-drop o 2) 16))

(define (asm->hex o)
  (let ((prefix ".byte "))
   (if (not (string-prefix? prefix o)) (begin (stderr "SKIP:~a\n" o)'())
       (let ((s (string-drop o (string-length prefix))))
         (map byte->hex (string-split s #\space))))))

(define (statement->text+globals+locals text+globals+locals)
  (lambda (o)
    ;;(stderr "S=~a\n" o)
    (let* ((text (.text text+globals+locals))
           (globals (.globals text+globals+locals))
           (locals (.locals text+globals+locals)))
      ;; (stderr "   tsl=~a\n" text+globals+locals)
      ;; (stderr "   locals=~s\n" locals)
      (pmatch o

        ((expr-stmt (fctn-call (p-expr (ident ,name))
                               (expr-list (p-expr (string ,string)))))
         ;;(stderr "S1 string=~a\n" string)
         (if (equal? name "asm")
             (make-text+globals+locals
              (append
               text
               (list (lambda (s t d) (asm->hex string))))
              globals
              locals)
             
             (make-text+globals+locals
              (append text
                      (list (lambda (s t d)
                              (i386:call s t d
                                         (+ t (function-offset name s))
                                         (+ d (data-offset string s))))))
              (append globals (list (string->globals string)))
              locals)))
        
        ((expr-stmt (fctn-call (p-expr (ident ,name)) (expr-list . ,expr-list)))
         ;;(stderr "S1 expr-list=~a\n" expr-list)
         (let* ((globals (append globals (filter-map expr->globals expr-list)))
                (args (map (expr->arg globals locals) expr-list)))
           (make-text+globals+locals
            (append text
                    (list (lambda (s t d) (apply i386:call (cons* s t d (+ t (function-offset name s)) args)))))
            globals
            locals)))

        ((compd-stmt (block-item-list . ,statements))
         (let loop ((statements statements)
                    (text+globals+locals (make-text+globals+locals text globals locals)))
           (if (null? statements) text+globals+locals
               (let* ((statement (car statements))
                      (r ((statement->text+globals+locals text+globals+locals) statement)))
                 (loop (cdr statements) r)))))

        ((if (gt (p-expr (ident ,name)) (p-expr (fixed ,value))) ,body)
         (let* ((value (string->number value))

                (t+s+l (make-text+globals+locals '() globals locals))

                (body-t+s+l ((statement->text+globals+locals t+s+l) body))
                (body-text (.text body-t+s+l))
                ;;(body-globals (.globals body-t+s+l))
                (globals (.globals body-t+s+l))
                (body-locals (.locals body-t+s+l))
                (body-length (length (text->list body-text))))

           (make-text+globals+locals
            (append text
                    (list (lambda (s t d)
                            (append
                             (i386:local-test (assoc-ref locals name) value)
                             (i386:jump-le body-length))))
                    body-text)
            globals
            locals)))

        ((while ,test ,body)
         (let* ((t+s+l (make-text+globals+locals '() globals locals))

                (body-t+s+l ((statement->text+globals+locals t+s+l) body))
                (body-text (.text body-t+s+l))
                ;;(body-globals (.globals body-t+s+l))
                (globals (.globals body-t+s+l))
                (body-locals (.locals body-t+s+l))
                (body-length (length (text->list body-text)))

                (test-t+s+l ((statement->text+globals+locals t+s+l) test))
                (test-text (.text test-t+s+l))
                (test-globals (.globals test-t+s+l))
                (test-locals (.locals test-t+s+l))
                (test-length (length (text->list test-text))))

           (make-text+globals+locals
            (append text
                    (list (lambda (s t d) (i386:jump body-length)))
                    body-text
                    test-text
                    (list (lambda (s t d) (i386:jump-nz (- (+ body-length test-length))))))
            globals
            locals)))

        ((array-ref (p-expr (fixed ,value)) (p-expr (ident ,name)))
         (let ((value (string->number value)))
           (make-text+globals+locals
            (append
             text
             (list
              (lambda (s t d)
                (append
                 ((ident->base locals) name)
                 (i386:value->accu value)
                 (i386:mem-byte->accu))))) ; FIXME: type: char
            globals
            locals)))
        
        ((array-ref (p-expr (ident ,name)) (p-expr (ident ,index)))
         (make-text+globals+locals
          (append
           text
           (list
            (lambda (s t d)
              (append
               ((ident->base locals) name)
               ((ident->accu locals) index)
               (i386:mem-byte->accu))))) ; FIXME: type: char
          globals
          locals))
         
        ((expr-stmt (post-inc (p-expr (ident ,name))))
         (make-text+globals+locals
          (append text
                  (list (lambda (s t d) (i386:local-add (assoc-ref locals name) 1))))
          globals
          locals))

        ((return ,expr)
         (make-text+globals+locals
          (append text (list (i386:ret ((expr->accu globals locals) expr))))
          globals
          locals))

        ;; int i;
        ((decl (decl-spec-list (type-spec (fixed-type ,type))) (init-declr-list (init-declr (ident ,name))))
         (let ((locals (acons name (1+ (or (and=> (member 1 (map cdr locals)) length) 0)) locals)))
           (make-text+globals+locals text globals locals)))

        ((decl (decl-spec-list (type-spec (fixed-type ,type))) (init-declr-list (init-declr (ident ,name) (initzer (p-expr (fixed ,value))))))
         (let ((locals (acons name (1+ (or (and=> (member 1 (map cdr locals)) length) 0)) locals))
               (value (string->number value)))
           (make-text+globals+locals
            (append
             text
             (list (lambda (s t d) (i386:local-assign (assoc-ref locals name) value))))
            globals
            locals)))

        ;; int i = argc;
        ((decl (decl-spec-list (type-spec (fixed-type ,type))) (init-declr-list (init-declr (ident ,name) (initzer (p-expr (ident ,local))))))
         (let ((locals (acons name (1+ (or (and=> (member 1 (map cdr locals)) length) 0)) locals)))
           (make-text+globals+locals
            (append
             text
             (list (lambda (s t d)
                     (append
                      ((ident->accu locals) local)
                      ((accu->ident locals) name)))))
            globals
            locals)))
        
        ;; SCM i = argc;
        ((decl (decl-spec-list (type-spec (typename ,type))) (init-declr-list (init-declr (ident ,name) (initzer (p-expr (ident ,local))))))
         (let ((locals (acons name (1+ (or (and=> (member 1 (map cdr locals)) length) 0)) locals)))
           (make-text+globals+locals
            (append
             text
             (list (lambda (s t d)
                     (append
                      ((ident->accu locals) local)
                      ((accu->ident locals) name)))))
            globals
            locals)))
        
        ;; int i = f ();
        ((decl (decl-spec-list (type-spec (fixed-type ,type))) (init-declr-list (init-declr (ident ,name) (initzer (fctn-call . ,call)))))
         (let ((locals (acons name (1+ (or (and=> (member 1 (map cdr locals)) length) 0)) locals)))
           (let* ((t+s+l (make-text+globals+locals text globals locals))
                  (t+s+l ((statement->text+globals+locals t+s+l)
                          `(expr-stmt (fctn-call ,@call))))
                  (text (.text t+s+l))
                  (globals (.globals t+s+l))
                  (locals (.locals t+s+l)))
             (make-text+globals+locals
              (append
               text
               (list (lambda (s t d) (i386:ret-local (assoc-ref locals name)))))
              globals
              locals))))
        
        ;; i = 0;
        ((expr-stmt (assn-expr (p-expr (ident ,name)) (op _) (p-expr (fixed ,value))))
         ;;(stderr "RET LOCAL[~a]: ~a\n" name (assoc-ref locals name))
         (let ((value (string->number value)))
           (make-text+globals+locals
            (append text (list (lambda (s t d) (i386:local-assign (assoc-ref locals name) value))))
            globals
            locals)))
        
        ((expr-stmt (assn-expr (p-expr (ident ,name)) (op _) (fctn-call . ,call)))
         (let* ((t+s+l ((statement->text+globals+locals text+globals+locals)
                        `(expr-stmt (fctn-call ,@call))))
                (text (.text t+s+l))
                (globals (.globals t+s+l))
                (locals (.locals t+s+l)))
           (make-text+globals+locals
            (append text (list (lambda (s t d) (i386:ret-local (assoc-ref locals name)))))
            globals
            locals)))

        (_
         (format (current-error-port) "SKIP statement=~a\n" o)
         text+globals+locals)))))

(define (globals->exe globals)
  (display "dumping elf\n" (current-error-port))
  (map write-any (make-elf globals)))

(define (.formals o)
  (pmatch o
    ((fctn-defn _ (ftn-declr _ ,formals) _) formals)
    ((fctn-defn _ (ptr-declr (pointer) (ftn-declr _ ,formals)) _) formals)
    (_ (format (current-error-port) ".formals: no match: ~a\n" o)
       barf)))

(define (formal->text n)
  (lambda (o i)
    ;;(i386:formal i n)
    '()
    ))

(define (formals->text o)
  (pmatch o
    ((param-list . ,formals)
     (let ((n (length formals)))
       (list (lambda (s t d)
               (append
                (i386:function-preamble)
                (append-map (formal->text n) formals (iota n))
                (i386:function-locals))))))
    (_ (format (current-error-port) "formals->text: no match: ~a\n" o)
       barf)))

(define (formals->locals o)
  (pmatch o
    ((param-list . ,formals)
     (let ((n (length formals)))
       ;;(stderr "FORMALS: ~a ==> ~a\n" formals n)
      (map cons (map .name formals) (iota n -2 -1))))
    (_ (format (current-error-port) "formals->globals: no match: ~a\n" o)
       barf)))

(define (string->globals string)
  (make-data string (append (string->list string) (list #\nul))))

(define (function->globals globals)
  (lambda (o)
    ;;(stderr "\n")
    (format (current-error-port) "compiling ~a\n" (.name o))
    ;;(stderr "formals=~a\n" (.formals o))
    (let* ((text (formals->text (.formals o)))
           (locals (formals->locals (.formals o))))
      ;;(stderr "locals=~a\n" locals)
      (let loop ((statements (.statements o))
                 (text+globals+locals (make-text+globals+locals text globals locals)))
        (if (null? statements) (append (.globals text+globals+locals) (list (make-function (.name o) (.text text+globals+locals))))
            (let* ((statement (car statements)))
              (loop (cdr statements)
                    ((statement->text+globals+locals text+globals+locals) (car statements)))))))))

(define _start
  (let* ((argc-argv
          (string-append ".byte"
                         " 0x89 0xe8"      ; mov    %ebp,%eax
                         " 0x83 0xc0 0x08" ; add    $0x8,%eax
                         " 0x50"           ; push   %eax
                         " 0x89 0xe8"      ; mov    %ebp,%eax
                         " 0x83 0xc0 0x04" ; add    $0x4,%eax
                         " 0x0f 0xb6 0x00" ; movzbl (%eax),%eax
                         " 0x50"           ; push   %eax
                         ))
         (ast (with-input-from-string
                  
                  (string-append "int _start () {int i;asm(\"" argc-argv "\");i=main ();exit (i);}")
                parse-c99))
         (functions (filter ast:function? (cdr ast))))
    ;;(pretty-print ast (current-error-port))
    (list (find (lambda (x) (equal? (.name x) "_start")) functions))))

(define strlen
  (let* ((ast (with-input-from-string
                  "
int
strlen (char const* s)
{
  int i = 0;
  while (s[i]) i++;
    return i;
}
"
                parse-c99))
         (functions (filter ast:function? (cdr ast))))
    ;;(pretty-print ast (current-error-port))
    (list (find (lambda (x) (equal? (.name x) "strlen")) functions))))

(define eputs
  (let* ((ast (with-input-from-string
                  "
int
eputs (char const* s)
{
  //write (STDERR, s, strlen (s));
  //write (2, s, strlen (s));
  int i = strlen (s);
  write (2, s, i);
  return 0;
}
"
                parse-c99))
         (functions (filter ast:function? (cdr ast))))
    ;;(pretty-print ast (current-error-port))
    (list (find (lambda (x) (equal? (.name x) "eputs")) functions))))

(define fputs
  (let* ((ast (with-input-from-string
                  "
int
fputs (char const* s, int fd)
{
  int i = strlen (s);
  write (fd, s, i);
  return 0;
}
"
                parse-c99))
         (functions (filter ast:function? (cdr ast))))
    ;;(pretty-print ast (current-error-port))
    (list (find (lambda (x) (equal? (.name x) "fputs")) functions))))

(define puts
  (let* ((ast (with-input-from-string
                  "
int
puts (char const* s)
{
  //write (STDOUT, s, strlen (s));
  //int i = write (STDOUT, s, strlen (s));
  int i = strlen (s);
  write (1, s, i);
  return 0;
}
"
                parse-c99))
         (functions (filter ast:function? (cdr ast))))
    ;;(pretty-print ast (current-error-port))
    (list (find (lambda (x) (equal? (.name x) "puts")) functions))))

(define i386:libc
  (list
   (make-function "exit" (list i386:exit))
   (make-function "write" (list i386:write))))

(define libc
  (append
   strlen
   eputs
   fputs
   puts))

(define (compile)
  (let* ((ast (mescc))
         (functions (filter ast:function? (cdr ast)))
         (functions (append libc functions _start)))
    (let loop ((functions functions) (globals i386:libc))
      (if (null? functions) (globals->exe globals)
          (loop (cdr functions) ((function->globals globals) (car functions)))))))
