;;; -*-scheme-*-

;;; Mes --- Maxwell Equations of Software
;;; Copyright Â© 2016,2017,2018 Jan (janneke) Nieuwenhuizen <janneke@gnu.org>
;;;
;;; This file is part of Mes.
;;;
;;; Mes is free software; you can redistribute it and/or modify it
;;; under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 3 of the License, or (at
;;; your option) any later version.
;;;
;;; Mes is distributed in the hope that it will be useful, but
;;; WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with Mes.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;;; Code:

(define-macro (define-module module . rest) #t)
(define-macro (use-modules . rest) #t)
(define-macro (cond-expand-provide . rest) #t)

(define-macro (include-from-path file)
  (let loop ((path (cons %moduledir (string-split (or (getenv "GUILE_LOAD_PATH") "") #\:))))
    (if (getenv "MES_DEBUG")
        ;;(format (current-error-port) "include-from-path: ~s [PATH:~s]\n" file path)
        (core:display-error (string-append "include-from-path: " file " [PATH:" (string-join path ":") "]\n")))
    (if (null? path) (error "include-from-path: not found: " file)
        (let ((file (string-append (car path) "/" file)))
          (if (access? file R_OK) `(load ,file)
              (loop (cdr path)))))))

(mes-use-module (mes catch))
(mes-use-module (mes posix))
(mes-use-module (srfi srfi-16))
(mes-use-module (srfi srfi-26))
(mes-use-module (mes display))

(if #t ;;(not (defined? 'read-string))
    (define (read-string)
      (define (read-string c)
        (if (eq? c #\*eof*) '()
            (cons c (read-string (read-char)))))
      (let ((string (list->string (read-string (read-char)))))
        (if (and=> (getenv "MES_DEBUG") (compose (cut > <> 2) string->number))
            (core:display-error (string-append "drained: `" string "'\n")))
        string)))

(define (drain-input port) (read-string))

(define (make-string n . fill)
  (list->string (apply make-list n fill)))

(define (object->string x . rest)
  (with-output-to-string
    (lambda () ((if (pair? rest) (car rest) write) x))))

(define (port-filename p) "<stdin>")
(define (port-line p) 0)

(define (with-input-from-string string thunk)
  (define save-peek-char peek-char)
  (define save-read-char read-char)
  (define save-unread-char unread-char)
  (if (and=> (getenv "MES_DEBUG") (compose (cut > <> 2) string->number))
      (core:display-error (string-append "with-input-from-string: `" string "'\n")))
  (let ((tell 0)
        (end (string-length string)))
    (set! peek-char
          (lambda ()
            (if (= tell end) (integer->char -1)
                (string-ref string tell))))
    (set! read-char
          (lambda () (if (= tell end) (integer->char -1)
                         (begin
                           (set! tell (1+ tell))
                           (string-ref string (- tell 1))))))
    (set! unread-char
          (lambda (c) (set! tell (1- tell)) c)))
  (let ((r (thunk)))
    (set! peek-char save-peek-char)
    (set! read-char save-read-char)
    (set! unread-char save-unread-char)
    r))

(define (with-input-from-file file thunk)
  (let ((port (open-input-file file)))
    (if (= port -1)
        (error 'no-such-file file)
        (let* ((save (current-input-port))
               (foo (set-current-input-port port))
               (r (thunk)))
          (set-current-input-port save)
          r))))

(define (with-output-to-file file thunk)
  (let ((port (open-output-file file)))
    (if (= port -1)
        (error 'cannot-open file)
        (let* ((save (current-output-port))
               (foo (set-current-output-port port))
               (r (thunk)))
          (set-current-output-port save)
          r))))

(define (with-output-to-port port thunk)
  (let* ((save (current-output-port))
         (foo (set-current-output-port port))
         (r (thunk)))
    (set-current-output-port save)
    r))

(define core:open-input-file open-input-file)
(define (open-input-file file)
  (let ((port (core:open-input-file file)))
    (when (getenv "MES_DEBUG")
      (core:display-error (string-append "open-input-file: `" file "'\n"))
      (core:display-error "port=")
      (core:display-error port)
      (core:display-error "\n"))
    port))

(define open-input-string
  (let ((save-set-current-input-port #f)
        (string-port #f))
    (lambda (string)
      (if (and=> (getenv "MES_DEBUG") (compose (cut > <> 2) string->number))
          (core:display-error (string-append "open-input-string: `" string "'\n")))
      (set! save-set-current-input-port set-current-input-port)
      (set! string-port (cons '*string-port* (gensym)))
      (set! set-current-input-port
            (let ((save-peek-char peek-char)
                  (save-read-char read-char)
                  (save-unread-char unread-char)
                  (tell 0)
                  (end (string-length string)))
              (lambda (port)
                (when (and=> (getenv "MES_DEBUG") (compose (cut > <> 2) string->number))
                    (core:display-error (string-append "open-input-string: `" string "' save-set-current-input-port port="))
                    (core:display-error port)
                    (core:display-error "\n"))
                (if (not (equal? port string-port)) (save-set-current-input-port port)
                    (begin
                      (set! tell 0)
                      (set! peek-char
                            (lambda () (if (= tell end) (integer->char -1)
                                           (string-ref string tell))))
                      (set! read-char
                            (lambda () (if (= tell end) (integer->char -1)
                                           (begin
                                             (set! tell (1+ tell))
                                             (string-ref string (- tell 1))))))
                      (set! unread-char
                            (lambda (c) (set! tell (1- tell)) c))
                      (set! set-current-input-port
                            (lambda (port)
                              (when (getenv "MES_DEBUG")
                                (core:display-error (string-append "open-input-string: `" string "' set-current-input-port port="))
                                (core:display-error port)
                                (core:display-error "\n"))
                              (save-set-current-input-port port)
                              (set! peek-char save-peek-char)
                              (set! read-char save-read-char)
                              (set! unread-char save-unread-char)
                              (set! set-current-input-port save-set-current-input-port)
                              string-port)))))))
      string-port)))

(define (dirname file-name)
  (let ((lst (filter (negate string-null?) (string-split file-name #\/))))
    (if (<= (length lst) 1) "."
        (string-join (list-head lst (1- (length lst))) "/"))))

;; FIXME: c&p from display
(define (with-output-to-string thunk)
  (define save-write-byte write-byte)
  (let ((stdout '()))
    (set! write-byte
          (lambda (x . rest)
            (let ((out? (or (null? rest) (eq? (car rest) (current-output-port)))))
              (if (not out?) (apply save-write-byte (cons x rest))
                  (begin
                    (set! stdout (append stdout (list (integer->char x))))
                    x)))))
    (thunk)
    (let ((r (apply string stdout)))
      (set! write-byte save-write-byte)
      r)))

;; FIXME: c&p from display
(define (simple-format destination format . rest)
  (let ((port (if (boolean? destination) (current-output-port) destination))
        (lst (string->list format)))
    (define (simple-format lst args)
      (if (pair? lst)
          (let ((c (car lst)))
            (if (not (eq? c #\~)) (begin (write-char (car lst) port)
                                         (simple-format (cdr lst) args))
                (let ((c (cadr lst)))
                  (case c
                    ((#\a) (display (car args) port))
                    ((#\s) (write (car args) port)))
                  (simple-format (cddr lst) (cdr args)))))))

    (if destination (simple-format lst rest)
        (with-output-to-string
          (lambda () (simple-format lst rest))))))
(define format simple-format)

