;;; -*-scheme-*-

;;; Mes --- Maxwell Equations of Software
;;; Copyright Â© 2016 Jan Nieuwenhuizen <janneke@gnu.org>
;;;
;;; loop-0.mes: This file is part of Mes.
;;;
;;; Mes is free software; you can redistribute it and/or modify it
;;; under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 3 of the License, or (at
;;; your option) any later version.
;;;
;;; Mes is distributed in the hope that it will be useful, but
;;; WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with Mes.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;;; loop-0.mes - bootstrap into Scheme from minimal -DBOOT=1 core.

;;; When compiling mes.c with -DBOOT=1, eval/apply et al. are lacking
;;; features wrt the fat-c variant, e.g., define and define-macro are
;;; not available; instead label is supplied.  Before loading
;;; boot-0.mes, loop-0.mes is loaded to provide a richer eval/apply.

;;; This might enable moving more functionality from C to Scheme,
;;; making the entirely-from-source bootstrap process more feasible.
;;; However, currently performance is 400x worse.  Also several tests
;;; in the test suite fail and the REPL does not work yet.

;;; Code:

((label loop-0
        (lambda (r e a)
          ;; (display "***LOOP-0*** ... e=") (display e) (newline)
          (if (null? e) (eval (read-file (read-env a) a) a)
              (if (atom? e) (loop-0 (eval e a) (read-env a) a)
                  (if (eq? (car e) 'define)
                      ((lambda (aa)     ; env:define
                         ;; (display "0DEFINE name=") (display (cadr e)) (newline)
                         (set-cdr! aa (cdr a))
                         (set-cdr! a aa)
                         (set-cdr! (assq '*closure* a) a)
                         (loop-0 *unspecified* (read-env a) a))
                       (cons            ; sexp:define
                        (if (atom? (cadr e)) (cons (cadr e) (eval (caddr e) a))
                            (cons (caadr e) (eval (cons 'lambda (cons (cdadr e) (cddr e))) a)))
                        '()))
                      (if (eq? (car e) 'define-macro)
                          ((lambda (name+entry) ; env:macro
                             ;; (display "0MACRO name=") (display (car name+entry)) (newline)
                             ((lambda (aa) ; env:define
                                (set-cdr! aa (cdr a))
                                (set-cdr! a aa)
                                (set-cdr! (assq '*closure* a) a)
                                (loop-0 *unspecified* (read-env a) a))
                              (cons
                               (cons (car name+entry)
                                     (make-macro (car name+entry)
                                                 (cdr name+entry)))
                               '())))
                                        ; sexp:define
                           (if (atom? (cadr e)) (cons (cadr e) (eval (caddr e) a))
                               (cons (caadr e) (eval (cons 'lambda (cons (cdadr e) (cddr e))) a)))
                           '())
                          (loop-0 (eval e a) (read-env a) a)))))))
 *unspecified* (read-env '()) (current-module))

()
;; enter reading loop-0
(display "loop-0 ...\n")

(define-macro (cond . clauses)
  (list 'if (null? clauses) *unspecified*
        (if (null? (cdr clauses))
            (list 'if (car (car clauses))
                  (list (cons 'lambda (cons '() (cons (car (car clauses)) (cdr (car clauses))))))
                  *unspecified*)
            (if (eq? (car (cadr clauses)) 'else)
                (list 'if (car (car clauses))
                      (list (cons 'lambda (cons '() (car clauses))))
                      (list (cons 'lambda (cons '() (cons *unspecified* (cdr (cadr clauses)))))))
                (list 'if (car (car clauses))
                      (list (cons 'lambda (cons '() (car clauses))))
                      (cons 'cond (cdr clauses)))))))

(define (map f l . r)
  (if (null? l) '()
      (if (null? r) (cons (f (car l)) (map f (cdr l)))
          (if (null? (cdr r))
              (cons (f (car l) (caar r)) (map f (cdr l) (cdar r)))))))

(define-macro (simple-let bindings . rest)
  (cons (cons 'lambda (cons (map car bindings) rest))
        (map cadr bindings)))

(define-macro (let bindings . rest)
  (cons 'simple-let (cons bindings rest)))

(define-macro (or . x)
  (if (null? x) #f
      (if (null? (cdr x)) (car x)
          (list 'if (car x) (car x)
                (cons 'or (cdr x))))))

(define-macro (and . x)
  (if (null? x) #t
      (if (null? (cdr x)) (car x)
          (list 'if (car x) (cons 'and (cdr x))
                #f))))

(define (not x)
  (if x #f #t))

(define (evlis-env m a)
  (cond
   ((null? m) '())
   ((not (pair? m)) (eval m a))
   (#t (cons (eval (car m) a) (evlis-env (cdr m) a)))))

(define (apply-env fn x a) 
  (cond
   ((atom? fn)
    (cond
     ((builtin? fn) (call fn x))
     ((eq? fn 'call-with-values) (c:apply-env 'call-with-values x a))
     ((eq? fn 'current-module) a)
     (#t (apply-env (eval fn a) x a))))
   ((eq? (car fn) 'lambda)
    (let ((p (pairlis (cadr fn) x a)))
      (cache-invalidate-range p (cdr a))
      (let ((r (eval (cons 'begin (cddr fn)) (cons (cons '*closure* p) p))))
        (cache-invalidate-range p (cdr a))
        r)))
   ((eq? (car fn) '*closure*)
    (let ((args (caddr fn))
          (body (cdddr fn))
          (a (cddr (cadr fn))))
      (let ((p (pairlis args x a)))
        (cache-invalidate-range p (cdr a))
        (let ((r (eval (cons 'begin body) (cons (cons '*closure* p) p))))
          (cache-invalidate-range p (cdr a))
          r))))
   ;;((eq? (car fn) 'label) (apply-env (caddr fn) x (cons (cons (cadr fn) (caddr fn)) a)))
   (#t (apply-env (eval fn a) x a))))

(define (eval-expand e a)
  (cond
   ((internal? e) e)
   ((builtin? e) e)
   ((char? e) e)
   ((number? e) e)
   ((string? e) e)
   ((vector? e) e)
   ((symbol? e) (assq-ref-cache e a))
   ((atom? (car e))
    (cond
     ((eq? (car e) 'quote) (cadr e))
     ((eq? (car e) 'syntax) (cadr e))
     ((eq? (car e) 'begin) (eval-begin-env e a))
     ((eq? (car e) 'lambda) (make-closure (cadr e) (cddr e) (assq '*closure* a)))
     ((eq? (car e) '*closure*) e)
     ((eq? (car e) 'if) (eval-if-env (cdr e) a))
     ((eq? (car e) 'define) (env:define (cons (sexp:define e a) '()) a))
     ((eq? (car e) 'define-macro) (env:define (env:macro (sexp:define e a)) a))
     ((eq? (car e) 'set!) (set-env! (cadr e) (eval (caddr e) a) a))
     ((eq? (car e) 'unquote) (eval (cadr e) a))
     ((eq? (car e) 'quasiquote) (eval-quasiquote (cadr e) (add-unquoters a)))
     (#t (apply-env (car e) (evlis-env (cdr e) a) a))))
   (#t (apply-env (car e) (evlis-env (cdr e) a) a))))

(define (unquote x) (cons 'unquote x))
(define (unquote-splicing x) (cons 'quasiquote x))

(define (add-unquoters a)
  (cons (cons 'unquote unquote)
        (cons (cons 'unquote-splicing unquote-splicing) a)))

(define (eval e a)
  (eval-expand (expand-macro-env e a) a))

(define (expand-macro-env e a)
  (if (pair? e) ((lambda (macro)
                   (if macro (expand-macro-env (apply-env macro (cdr e) a) a)
                       e))
                 (lookup-macro (car e) a))
      e))

(define (eval-begin-env e a)
  (if (null? e) *unspecified*
      (if (null? (cdr e)) (eval (car e) a)
          (begin
            (eval (car e) a)
            (eval-begin-env (cdr e) a)))))

(define (eval-if-env e a)
  (if (eval (car e) a) (eval (cadr e) a)
      (if (pair? (cddr e)) (eval (caddr e) a))))

(define (eval-quasiquote e a)
  (cond ((null? e) e)
        ((atom? e) e)
        ((eq? (car e) 'unquote) (eval (cadr e) a))
        ((and (pair? (car e))
              (eq? (caar e) 'unquote-splicing))
         (append2 (eval (cadar e) a) (eval-quasiquote (cdr e) a)))
        (#t (cons (eval-quasiquote (car e) a) (eval-quasiquote (cdr e) a)))))

(define (sexp:define e a)
  (if (atom? (cadr e)) (cons (cadr e) (eval (caddr e) a))
      (cons (caadr e) (eval (cons 'lambda (cons (cdadr e) (cddr e))) a))))

(define (env:define a+ a)
  (set-cdr! a+ (cdr a))
  (set-cdr! a a+)
  (set-cdr! (assq '*closure* a) a))

(define (env:macro name+entry)
  (cons
   (cons (car name+entry)
         (make-macro (car name+entry)
                     (cdr name+entry)))
   '()))

;; boot into loop-0
(cache-invalidate-range (current-module) '())
()
ignored
