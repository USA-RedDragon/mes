;;; -*-scheme-*-

;;; Mes --- Maxwell Equations of Software
;;; Copyright Â© 2017,2018 Jan (janneke) Nieuwenhuizen <janneke@gnu.org>
;;;
;;; This file is part of Mes.
;;;
;;; Mes is free software; you can redistribute it and/or modify it
;;; under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 3 of the License, or (at
;;; your option) any later version.
;;;
;;; Mes is distributed in the hope that it will be useful, but
;;; WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with Mes.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;;; M1.mes produces stage0' M1 object format

;;; Code:

(cond-expand
 (guile)
 (mes
  (mes-use-module (srfi srfi-1))
  (mes-use-module (srfi srfi-26))
  (mes-use-module (mes as))
  (mes-use-module (mes elf))
  (mes-use-module (mes optargs))
  (mes-use-module (mes pmatch))
  (mes-use-module (language c99 info))))

(define (logf port string . rest)
  (apply format (cons* port string rest))
  (force-output port)
  #t)

(define (stderr string . rest)
  (apply logf (cons* (current-error-port) string rest)))

(define (objects->M1 objects)
  ((compose object->M1 merge-objects) objects))

(define (object->elf o)
  ((compose M1->elf object->M1) o))

(define (objects->elf objects)
  ((compose M1->elf object->M1 merge-objects) objects))

(define (merge-objects objects)
  (let loop ((objects (cdr objects)) (object (car objects)))
    (if (null? objects) object
        (loop (cdr objects)
              `((functions . ,(alist-add (assoc-ref object 'functions) (assoc-ref (car objects) 'functions)))
                (globals . ,(alist-add (assoc-ref object 'globals) (assoc-ref (car objects) 'globals))))))))

(define (alist-add a b)
  (let* ((b-keys (map car b))
         (a (filter (lambda (f) (or (cdr f) (not (member (car f) b-keys)))) a))
         (a-keys (map car a)))
    (append a (filter (lambda (e) (not (member (car e) a-keys))) b))))

(define (hex2:address o)
  (string-append "&" o))

(define (hex2:offset o)
  (string-append "%" o))

(define (hex2:offset1 o)
  (string-append "!" o))

(define hex? #t)

(define (hex2:immediate o)
  (if hex? (string-append "%0x" (dec->hex o))
      (string-append "%" (number->string o))))

(define (hex2:immediate1 o)
  (if hex? (string-append "!0x" (dec->hex o))
      (string-append "!" (number->string o))))

(define (object->M1 o)
  (stderr "dumping M1: object\n")
  (let* ((functions (assoc-ref o 'functions))
         (function-names (map car functions))
         (file-name (car (or (assoc-ref o 'file-names) function-names)))
         (globals (assoc-ref o 'globals))
         (global-names (map car globals))
         (strings (filter (lambda (g) (and (pair? g) (eq? (car g) #:string))) global-names)))
    (define (string->label o)
      (let ((index (list-index (lambda (s) (equal? s o)) strings)))
        (if index
            (string-append "_string_" file-name "_" (number->string index))
            "")))
    (define (text->M1 o)
      (cond
       ((char? o) (text->M1 (char->integer o)))
       ((string? o) o)
       ((symbol? o) (symbol->string o))
       ((number? o) (let ((o (if (< o #x80) o (- o #x100))))
                      (if hex? (string-append "!0x"
                                              (if (and (>= o 0) (< o 16)) "0" "")
                                              (number->string o 16))
                          (string-append "!" (number->string o)))))
       ((and (pair? o) (keyword? (car o)))
        (pmatch o
         ;; FIXME
         ((#:address (#:string ,string)) (hex2:address (string->label `(#:string ,string))))
         ((#:string (#:address ,address)) (hex2:address address))
         ((#:address (#:address ,address)) (hex2:address address))
         ((#:string ,string) (hex2:address (string->label o)))
         ((#:address ,address) (hex2:address address))
         ((#:offset ,offset) (hex2:offset offset))
         ((#:offset1 ,offset1) (hex2:offset1 offset1))
         ((#:immediate ,immediate) (hex2:immediate immediate))
         ((#:immediate1 ,immediate1) (hex2:immediate1 immediate1))))
       ((pair? o) (string-join (map text->M1 o)))))
    (define (write-function o)
      (let ((name (car o))
            (text (cdr o)))
        (define (line->M1 o)
          (cond ((eq? (car o) #:label)
                 (core:display (string-append ":" (cadr o))))
                ((eq? (car o) #:comment)
                 (core:display (string-append "\t\t\t\t\t# " (text->M1 (cadr o)))))
                ((or (string? (car o)) (symbol? (car o)))
                 (core:display (string-append "\t" (string-join (map text->M1 o) " "))))
                (else (error "line->M1 invalid line:" o)))
          (newline))
        (core:display-error (string-append "    :" name "\n"))
        (core:display (string-append "\n\n:" name "\n"))
        (for-each line->M1 (apply append text))))
    (define (write-global o)
      (define (labelize o)
        (if (not (string? o)) o
            (let* ((label o)
                   (function? (member label function-names))
                   (string-label (string->label label))
                   (string? (not (equal? string-label "_string_#f")))
                   (global? (member label global-names)))
              (if (or global? string?) (string-append "&" label)
                  (begin (if (not function?) (stderr "warning: unresolved label: ~s\n" label))
                         (string-append "&" label))))))
      (let* ((label (if (not (and (pair? (car o)) (eq? (caar o) #:string))) (car o)
                        (string->label (car o))))
             (data (cdr o))
             (data (filter-map labelize data))
             (len (length data))
             (string-max (or (and=> (getenv "M1_STRING_MAX") string->number) 80)))
        (if (not (eq? (car (string->list label)) #\_))
            (core:display-error (string-append "    :" label "\n")))
        (core:display (string-append "\n:" label "\n"))
        (cond ((and (< len string-max)
                    (char? (car data))
                    (eq? (last data) #\nul)
                    (not (find (cut memq <> '(#\nul #\backspace #\return #\" #\')) (list-head data (1- (length data)))))
                    (not (any (lambda (ch) (>= (char->integer ch) #x80)) data)))
               (core:display (string-append "\"" (list->string (list-head data (1- (length data)))) "\"")))
              (else (core:display (string-join (map text->M1 data) " "))))
        (newline)))
    (core:display-error "M1: functions\n")
    (for-each write-function (filter cdr functions))
    (when (assoc-ref functions "main")
      (core:display "\n\n:ELF_data\n") ;; FIXME
      (core:display "\n\n:HEX2_data\n"))
    (core:display-error "M1: globals\n")
    (for-each write-global globals)))
