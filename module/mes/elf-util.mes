;;; -*-scheme-*-

;;; Mes --- Maxwell Equations of Software
;;; Copyright Â© 2016,2017 Jan Nieuwenhuizen <janneke@gnu.org>
;;;
;;; This file is part of Mes.
;;;
;;; Mes is free software; you can redistribute it and/or modify it
;;; under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 3 of the License, or (at
;;; your option) any later version.
;;;
;;; Mes is distributed in the hope that it will be useful, but
;;; WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with Mes.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;;; compiler.mes produces an i386 binary from the C produced by
;;; Nyacc c99.

;;; Code:

(cond-expand
 (guile)
 (guile-2)
 (mes
  (mes-use-module (srfi srfi-1))))

(define (make-function key value)
  (cons key (cons 'function value)))

(define (make-data key value)
  (cons key (cons 'data value)))

(define (function-symbol? x)
  (eq? (car x) 'function))

(define (function-entry? x)
  (function-symbol? (cdr x)))

(define (data-symbol? x)
  (eq? (car x) 'data))

(define (data-entry? x)
  (data-symbol? (cdr x)))

(define (globals->functions globals)
  (append-map cdr (filter function-symbol? (map cdr globals))))

(define (globals->text globals t d)
  (let loop ((functions (globals->functions globals)) (text '()))
    (if (null? functions) text
        (loop (cdr functions)
              (append text ((car functions) globals (- (length text)) d))))))

(define (function-offset name globals)
  (let* ((functions (filter function-entry? globals))
         (prefix (member name (reverse functions)
                         (lambda (a b)
                           (equal? (car b) name)))))
    (if prefix (length (globals->text (cdr prefix) 0 0))
        0)))

(define (data-offset name globals)
  (let* ((globals (filter data-entry? globals))
         (prefix (member name (reverse globals)
                         (lambda (a b)
                           (equal? (car b) name)))))
    (if prefix (length (globals->data (cdr prefix)))
        0)))

(define (globals->data globals)
  (append-map cdr (filter data-symbol? (map cdr globals))))
