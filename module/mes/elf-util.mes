;;; -*-scheme-*-

;;; Mes --- Maxwell Equations of Software
;;; Copyright Â© 2016,2017 Jan Nieuwenhuizen <janneke@gnu.org>
;;;
;;; This file is part of Mes.
;;;
;;; Mes is free software; you can redistribute it and/or modify it
;;; under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 3 of the License, or (at
;;; your option) any later version.
;;;
;;; Mes is distributed in the hope that it will be useful, but
;;; WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with Mes.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;;; compiler.mes produces an i386 binary from the C produced by
;;; Nyacc c99.

;;; Code:

(cond-expand
 (guile)
 (guile-2)
 (mes
  (mes-use-module (srfi srfi-1))))

(define (make-global name type pointer value)
  (cons name (list type pointer value)))

(define global:type car)
(define global:pointer cadr)
(define global:value caddr)

(define (drop-s:-prefix o) (substring o 2))
(define (add-s:-prefix o) (string-append "s:" o))

(define (dec->hex o)
  (cond ((number? o) (number->string o 16))
        ((char? o) (number->string (char->integer o) 16))))

(define (functions->lambdas functions)
  (append-map (lambda (f) (or (cdr f) '())) functions))

(define (lambda/label->list f g ta t d)
  (lambda (l/l)
    (if (not (procedure? l/l)) '() (l/l f g ta t d))))

(define (text->list o)
  (append-map (lambda/label->list '() '() 0 0 0) o))

(define functions->text
  (let ((cache '()))
    (lambda (functions globals ta t d)
      (or (assoc-ref cache (cons ta (map car functions)))
          (let ((text (let loop ((lambdas/labels (functions->lambdas functions)) (text '()))
                        (if (null? lambdas/labels) text
                            (loop (cdr lambdas/labels)
                                  (append text ((lambda/label->list functions globals ta (- (length text)) d) (car lambdas/labels))))))))
            (set! cache (assoc-set! cache (cons ta (map car functions)) text))
            text)))))

(define (function-prefix name functions)
  ;; FIXME
  ;;(member name (reverse functions) (lambda (a b) (equal? (car b) name)))
  (let* ((x functions)
         (x (if (and (pair? x) (equal? (caar x) "exit")) (reverse x) x)))
    (member name x (lambda (a b) (equal? (car b) name)))))

(define function-offset
  (let ((cache '()))
    (lambda (name functions)
      (or (assoc-ref cache name)
          (let* ((functions (if (and (pair? functions) (equal? (caar functions) "exit")) functions (reverse functions)))
                 (prefix (and=> (function-prefix name functions) cdr))
                 (offset (and prefix
                              (if (null? prefix) 0
                                  (+ (length (functions->text (list (car prefix)) '() 0 0 0))
                                     (if (null? (cdr prefix)) 0
                                         (function-offset (caar prefix) functions)))))))
            (if (and offset (or (equal? name "exit") (> offset 0))) (set! cache (assoc-set! cache name offset)))
            (or offset 0))))))

(define label-offset
  (let ((cache '()))
    (lambda (function label functions)
      (or (assoc-ref cache (cons function label))
          (let ((prefix (function-prefix function functions)))
            (if (not prefix) 0
                (let* ((function-entry (car prefix))
                       (offset (let loop ((text (cdr function-entry)))
                                 (if (or (equal? (car text) label) (null? text)) 0
                                     (let* ((l/l (car text))
                                            (t ((lambda/label->list '() '() 0 0 0) l/l))
                                            (n (length t)))
                                       (+ (loop (cdr text)) n))))))
                  (when (> offset 0)
                    (set! cache (assoc-set! cache (cons function label) offset)))
                  offset)))))))

(define (globals->data globals)
  (append-map (compose global:value cdr) globals))

(define data-offset
  (let ((cache '()))
    (lambda (name globals)
      (or ;;(assoc-ref cache name)
          (let* ((prefix (member name (reverse globals)
                                 (lambda (a b)
                                   (equal? (car b) name)))))
            (if (not prefix) 0
                (let ((offset (length (globals->data (cdr prefix)))))
                 (set! cache (assoc-set! cache name offset))
                 offset)))))))
