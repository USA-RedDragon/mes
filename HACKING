-*-mode:org-*-

* ROADMAP
** TODO release 0.5
  1. mes.c: prototype Scheme interpreter in C, mature enough to run
  2. guile/mescc.scm: C compiler on [Guile] Scheme, that can compile
     2a. scaffold/hello.c: Simplest C program, compiled with 2.
     2b. scaffold/micro-mes.c: main of 3. (2nd Scheme interpreter) + mlib.c
     2c. scaffold/cons-mes.c: run simple hardcoded sexp
     2d. scaffold/tiny-mes.c: load memory dump, run simple sexp
     2e. scaffold/t.c: c compiler tests, enough to support compiling
  3. scaffold/mini-mes.c: 2nd Scheme intepreter in C, without [g]libc, using
  4. mlib.c: Minimal Mescc C library
     4a. scaffold/hello.c: Simplest C program, compiled with 5.
     4b. scaffold/micro-mes.c: main of 3. (2nd Scheme interpreter) + mlib.c
     4x. *we are here, any more steps to reach 5*
     rm -f a.out; MES_DEBUG=1 scripts/mescc.mes scaffold/micro-mes.c > a.out
     4c. scaffold/cons-mes.c: run simple hardcoded sexp
     4d. scaffold/tiny-mes.c: load memory dump, run simple sexp
     4e. scaffold/t.c: run c test suite with scripts/mescc.mes
  5. scripts/mescc.mes: C compiler on mes, that can build mini-mes
     5a. remove __MESC__/__NYAC__ C workarounds in gc.c
     5b. module/language/c99/compiler.mes: refactor expr->arg, expr->accu, ast->info
     5c. merge *.c into scaffold/mini-mes.c
     5d. merge scaffold/mini-mes.c into mes.c
  6. scripts/mescc.mes: C compiler on mes, that can build mes
  7. release self-hosting Mes 0.5
     7a. discuss full source bootstrap strategy on guile-user with
     Orians Jeremiah (stage0+) Luca Saiu's (GNU Epsilon).
** release 0.x, unsorted
  - produce intermediate annotated assembly-like mes.S
  - AND/OR: connect to GNU Epsilon's VM
  - AND/OR: connect to OriansJ's stage0...LISP bootstrapping tools
  - real module support, bonus for supporting Guile's define-module/define-public syntax
  - get full source syntax-case up (Andre van Tonder?) OR drop
    psyntax/syntax-case and rewrite Nyacc without syntax-case+R7RS Ellipsis
  - support regexp OR rewrite Nyacc without regexps
  - split-off Guile C compiler as standalone Guile project, still
    respecting no-syntax-case bootstrap requirement
*** Compile the [[https://en.wikipedia.org/wiki/Tiny_C_Compiler][Tiny C Compiler]]
  - build tcc (tinycc)
** release 1.0
  - work to replace GuixSD's bootstrap binaries for x86
  - more architectures?

** DONE
** Support call-with-current-continuation, refactor catch/throw
** 0.4: Support Nyacc, Gcc-compiled Mes compiles minimal main.c using nyacc
** 0.3: Garbage collector
** 0.2: Support psyntax
** 0.1: Mes eval/apply feature complete; support syntax-rules, compile main.c using LALR, dump ELF

* Full source bootstrapping

** R6RS-like scheme interpreter
This first part is prototyped in C by the mes.c core and Scheme
bootstrap code in module/.  Of course, while mes.c is pretty small it
cannot serve as a full source solution.

The initial idea was to have the minimal core support LISP-1.5 (or
something very close to that as a tribute to John McCarthy) and extend
eval/apply from LISP-1.5 source with define, define-macro etc. and
metamorphose into R6RS.  It seemed to work but performance of the
LISP-intepreted RRS was so bad (~1000x slower than initial LISP-1.5)
that this track was abandoned after the initial ANNOUNCE.

The route changed, trying to strike a balance between core size and
performance: still writing as much as possible in Scheme but having a
mescc compiler that takes not more than some seconds to run.

Now that we have [[https://github.com/schemeway/lalr-scm][Dominique Boucher's LALR]], a [[https://www.cs.indiana.edu/chezscheme/syntax-case/old-psyntax.html][Pre-R6RS portable
syntax-case]] with R7RS ellipsis, [[http://www.nongnu.org/nyacc/][Nyacc]] and [[https://www.gnu.org/software/guile/docs/master/guile.html/PEG-Parsing.html][Guile's PEG]] parsers, it's
time to start doing something useful.

* Bugs
** The Scheme reader is very slow.
** Fluids are a hack for Nyacc.
** Prototype mes.c depends on a C compiler.
*** Translate C-prototype mes.c into annotated hex?
One idea is to use OriansJ's amazing self-hosting [[https://github.com/oriansj/stage0][stage0]] hex assembler
and minimal bootstrap binaries and rewrite the mes.c core to directly
bootstrap into Scheme.

*** Rewrite mes.c in Schemy/Sexp-C and generate annotated hex?
Another idea (thanks Rutger!) is to rewrite the mes.c core in a s-exp
C/Assembly variant and thave mescc produce the simple, annotated
bootstrap binary.

*** Compile the [[https://en.wikipedia.org/wiki/Tiny_C_Compiler][Tiny C Compiler]]

* OLD: Booting from LISP-1.5 into Mes

Mes started out experimenting with booting from a hex-coded minimal
LISP-1.5 (prototype in mes.c), into an almost-RRS Scheme.

When EOF is read, the LISP-1.5 machine calls loop2 from loop2.mes,
which reads the rest of stdin and takes over control.  The functions
readenv, eval and apply-env in mes.mes introduced define, define-macro
quasiquote and macro expansion.

While this works, it's amazingly slow.  We implemented a full reader
in mes.c, which makes running mes:apply-env mes:eval somewhat
bearable, still over 1000x slower than running mes.c.

Bootstrapping has been removed and mes.c implements enough of RRS to
run a macro-based define-syntax and syntax-rules.

loop.mes and mes.mes are unused and lagging behind.  Probably it's not
worth considering this route without a VM.  GNU Epsilon is taking the
more usual VM-route to provide multiple personas.  While that sounds
neat, Lisp/Scheme, bootstrapping and trusted binaries are probably not
in scope as there is no mention of such things; only ML is mentioned
while Guile is used for bootstrapping.

* Assorted ideas and info 
** Using GDB on assembly/a.out
info registers
p/x $eax
p/x $edx
set disassemble-next-line
gdb-display-disassembly-buffer
b *0x804a79d
** Create memory dump with 32 bit Gcc compiled Mes
guix environment --ad-hoc --system=i686-linux gcc-toolchain -- bash -c 'make mes CC=i686-unknown-linux-gnu-gcc LIBRARY_PATH=${PATH%%/bin:*}/lib'
mv mes mes-32
MES_TINY=1 ./mes-32 --dump < module/mes/tiny-0.mes > module/mes/tiny-0-32.mo
./mes-32 --dump < module/mes/read-0.mes > module/mes/read-0-32.mo
** C parser/compiler
*** [[https://savannah.gnu.org/projects/nyacc][nyacc]]
*** PEG: [[http://piumarta.com/software/peg/][parse C using PEG]]
*** [[https://en.wikipedia.org/wiki/Tiny_C_Compiler][Tiny C Compiler]]
*** [[http://www.t3x.org/subc/index.html][Sub C]]
*** [[https://groups.google.com/forum/#!topic/comp.lang.lisp/VPuX0VsjTTE][C intepreter in LISP/Scheme/Python]]

** C assembler/linker
*** [[http://www.tldp.org/HOWTO/Assembly-HOWTO/linux.html][Assembly HOWTO]]
*** ELF
7f 45 4c 46
*** [[http://www.muppetlabs.com/~breadbox/software/tiny/][Small ELF programs]]
*** [[http://www.cirosantilli.com/elf-hello-world/][Elf hello world]]
** SC - c as s-expressions
sc: http://sph.mn/content/3d3
** RNRS
*** [[http://www.scheme-reports.org/][Scheme Reports]] 
*** [[ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-349.pdf][Scheme - Report on Scheme]]
*** [[ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-452.pdf][RRS - Revised Report on Scheme]]

** tiny schemes
http://forum.osdev.org/viewtopic.php?f=15&t=19937

http://www.stripedgazelle.org/joey/dreamos.html
http://armpit.sourceforge.net/
http://common-lisp.net/project/movitz/movitz.html

<civodul> janneke: https://github.com/namin/inc looks interesting  [15:18]
** Orians Jeremiah
<OriansJ> janneke: also, if you look at
          https://github.com/oriansj/stage0/tree/master/stage2/High_level_prototypes
          [the garbage collected lisp I implemented], if there are any pieces
          I could add to finish off your mes lisp bootstrap just let me know
          because I would be more than happy to do that :D
<janneke> OriansJ: that's what I'm hoping for, that our efforts can be
          complementary and we can work together
*** lfam (~lfam@2601:47:4180:2ffb:7c05:17de:cf5f:23ef) has quit: Ping timeout:
    246 seconds  [00:22]
<janneke> exciting times!  [00:23]
<janneke> OriansJ: i looked a few times and saw 'LISP empty', so thanks for
          the pointer!  [00:24]
<civodul> OriansJ, janneke: from that page, there's also:
          https://web.archive.org/web/20160604035203fw_/http://homepage.ntlworld.com/edmund.grimley-evans/bcompiler.html

** C4/C500
https://web.archive.org/web/20160604041431/http://homepage.ntlworld.com/edmund.grimley-evans/cc500/cc500.c
https://github.com/rswier/c4/blob/master/c4.c
